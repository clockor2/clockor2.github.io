{"version":3,"file":"static/js/245.cea147e7.chunk.js","mappings":"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","sources":["features/engine/core.ts","features/engine/utils.ts","features/engine/bestFittingRoot.ts","features/engine/bfrWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["// eslint-disable-next-line \n\n\nimport {phylotree, rootToTip} from \"phylotree\" // for clock search TODO: Add best fitting root soon!\n// import { group } from \"console\";\n// import { maxHeaderSize } from \"http\";\n\nconst chroma = require(\"chroma-js\") // TODO: Learn about why this works instead of import\n\n// class to contain local clock model, incl. data points and information criteria\nexport interface LocalClockModel {\n  baseClock: Regression;\n  localClock: Regression[];\n  baseIC: InfoMetric;\n  localIC: InfoMetric;\n}\n// interface for info metric data\ninterface InfoMetric {\n  aic: number;\n  aicc: number;\n  bic: number;\n}\n\n// function to make plottable points\n// method for plotly plotting\nexport function plotify(lcm: LocalClockModel | null): Plotly.Data[] | null {\n  const plot = [] as Plotly.Data[];\n  if (lcm != null) {\n    // generate colour scale. Use viridis-ish default\n    const cols = chroma.scale(['#fafa6e', '#2A4858']).mode('lch').colors(lcm.localClock.length); // move this to state\n    // Pushing plotly object for base lock\n    var point = {\n      x: lcm.baseClock.x,\n      y: lcm.baseClock.y,\n      text: lcm.baseClock.tip,\n      marker: {color: '#000000', size: 5},\n      mode: \"markers\",\n      name: \"Global\",\n      legendgroup: \"0\",\n      showlegend: false\n    }\n    plot.push(point);\n\n    var line = {\n      x: lcm.baseClock.x,\n      y: lcm.baseClock.fitY,\n      name: `Global`,\n      marker : {color: '#000000'},\n      mode: \"lines\",\n      text: lcm.localClock.length > 1 \n      ? \n        `Baseline<br>R2: ${lcm.baseClock.r2.toFixed(2)}` \n      : \n        `R2: ${lcm.baseClock.r2.toFixed(2)}`,\n\n      legendgroup: \"0\"\n    }\n    plot.push(line);\n\n    // pushing plotly object for each local clock\n    for (let i = 0; i < lcm.localClock.length; i++) {\n      var point1 = {\n        x: lcm.localClock[i].x,\n        y: lcm.localClock[i].y,\n        text: lcm.localClock[i].tip,\n        marker: {color: cols[i]},\n        mode: \"markers\",\n        legendgroup: `${i + 1}`,\n        showlegend: false\n      }\n      plot.push(point1);\n\n      var line1 = {\n        x: lcm.localClock[i].x,\n        y: lcm.localClock[i].fitY,\n        text: `Local Clock: ${i + 1}<br>R2: ${lcm.localClock[i].r2.toFixed(2)}`,\n        marker : {color: cols[i]},\n        mode: \"lines\",\n        legendgroup: `${i + 1}`,\n        name: `Local Clock ${i + 1}`\n      }\n      plot.push(line1);\n    }\n      return plot;\n  } else {\n    return null;\n  }\n  }\n\n\n\ninterface Style {\n  color: string;\n}\n\n// Class to pass back to plot later. Will be produced by plotify method in \n// flcModel class\n// interface Data extends Plotly.PlotData {\n//   color: string\n// }\n\n// class regression for storing the points, r^2, slope, fit for a set of points x, y\n// inferface for ouput of regression functions\nexport interface Regression {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  fitY: Array<number>;\n  slope: number;\n  intercept: number;\n  sigSq: number;\n  r2: number;\n  logLik: number;\n}\n\n// Groups of points pertaining to one local clock\n// To be apended in array for linearRegression()\ninterface DataGroup {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n}\n\n//////////////////////////////////////////////////////\n// BELOW: CORE ENGINE FUNCTIONS SUCH AS SOMETHING() //\n// INCORPORATE FUNCTIONS DEFINED BELOW              //\n//////////////////////////////////////////////////////\n\n// Core function. Functionality for groups to be added\nexport const regression = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings: Array<number>,\n  tipNames: Array<string>) => {\n\n  var dataPoints = groupData(tipHeights, dates, groupings, tipNames);\n\n  var lcm = {} as LocalClockModel;\n  \n  lcm.baseClock = linearRegression(dataPoints[0]);\n  lcm.baseIC = {} as InfoMetric;\n  lcm.baseIC.aic = AIC([lcm.baseClock]);\n  lcm.baseIC.aicc = AICc([lcm.baseClock]);\n  lcm.baseIC.bic = BIC([lcm.baseClock]);\n\n  lcm.localClock = dataPoints.slice(1).map(e => linearRegression(e));\n  lcm.localIC = {} as InfoMetric;\n  lcm.localIC.aic = AIC(lcm.localClock);\n  lcm.localIC.aicc = AICc(lcm.localClock);\n  lcm.localIC.bic = BIC(lcm.localClock);\n  \n  return lcm;\n}\n\n// Clock search function. Conver to a generator later\n// icMetric is the information criterion used to find 'best' state. TODO: Need to read these as part of input: aic | aicc | bic\n// export const clockSearch = (tree: any,\n//   minCladeSize: number,\n//   numClocks: number,\n//   tipHeights: Array<number>,\n//   dates: Array<number>,\n//   tipNames: Array<string>,\n//   icMetric: string) => {\n\n//   // generate all possibilities for groupings\n//   let allGroups = getGroups(tree, minCladeSize, numClocks);\n//   let allGroupsNumber = allGroups.map((e: string[][]) => groupToNum(e, tips));\n\n//   // Loop through group possibilities and append to fits\n//   let fits: LocalClockModel[] = [];\n//   for (let i = 0; i < allGroups.length; i++){\n//       fits.push(regression(tipHeights, dates, allGroups[i], tipNames)); \n//   }\n\n//   // Now find the most supported configuration\n//   // Getting array of IC values based on selected IC TODO: Add capability for multiple ICs\n//   const ic = fits.map(e => e[icMetric as keyof LocalClockModel]) // TODO: Test here!\n\n//   var icMaxStep = ic.indexOf(Math.max(...(ic as number[]))); // TODO: This might throw an error if we never see output\n\n//   return fits[icMaxStep];\n// }\n\n////////////////////////////////////////////////////////\n// BELOW: FUNCTIONS USED INSIDE CORE ENGINE FUNCTIONS //\n////////////////////////////////////////////////////////\n\n// function groups points for local clock regresion\n// 0th element of array is always points for single clock\nconst groupData = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings: Array<number>,\n  tipNames: Array<string>\n  ): DataGroup[] => { \n  \n  let unique = groupings.filter((v, i, a) => a.indexOf(v) === i);\n\n  const points: DataGroup[] = [];\n\n  for (let i = 0; i < unique.length; i++) {\n    var tmp: DataGroup = {x: [], y: [], tip: []};\n    points.push(tmp);\n  }\n\n  for (let i = 0; i < groupings.length; i++) {\n    points[groupings[i]].x.push(\n      dates[i]\n    )\n    points[groupings[i]].y.push(\n      tipHeights[i]\n    )\n    points[groupings[i]].tip.push(\n      tipNames[i]\n    )\n  }\n  // if  num groups > 1, append the baseline fit (all points in one group)\n  // In the case num groups = 1, this is automatically appended\n  if (unique.length > 1) {\n    points.unshift({\n      x: dates,\n      y: tipHeights,\n      tip: tipNames\n    })}\n\n  return points;\n}\n\n// regression function \nexport function linearRegression(points: DataGroup) {\n  const reg = {} as Regression;\n\n  // carrying tips over first\n  reg.tip = points.tip;\n\n  let x = points.x;\n  let y = points.y;\n\n  var n = y.length;\n  var sum_x = 0;\n  var sum_y = 0;\n  var sum_xy = 0;\n  var sum_xx = 0;\n  var sum_yy = 0;\n\n  for (let j = 0; j < y.length; j++) {\n      sum_x += x[j];\n      sum_y += y[j];\n      sum_xy += (x[j]*y[j]);\n      sum_xx += (x[j]*x[j]);\n      sum_yy += (y[j]*y[j]);\n  } \n\n  // Include these later after agreeing on how to pass to front end\n  reg.x = x;\n  reg.y = y;\n  reg.slope = (n * sum_xy - sum_x * sum_y) / (n*sum_xx - sum_x * sum_x);\n  reg.intercept = (sum_y - reg.slope * sum_x)/n;\n  reg.fitY = x.map(e => (reg.slope * e + reg.intercept));\n  reg.r2 = Math.pow((n*sum_xy - sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);\n  //calculate log likelihood\n  \n  let error = y.map((n, i, a) => y[i] - reg.fitY[i]); \n  // estiamted variance of error\n  let sigSq = error.map(n => Math.pow(n, 2)).reduce(\n    (a, b) => a + b, 0) * (1 / reg.fitY.length);\n  //reg.logLik = y.map((e, i) => Math.log(normalDensity(e, reg.fitY[i], sigSq))).reduce((a, b) => a + b); \n  reg.logLik = y.map((e, i) => Math.log(\n    normalDensity(e, reg.fitY[i], sigSq)\n    )\n    ).reduce(\n      (a, b) => a + b\n      ); \n\n  return reg;\n}\n\n// Function for likelihood in linearRegression() function\n export function normalDensity(y: number, mu: number, sigSq: number) {\n  let exp = -0.5 * ((y - mu) ** 2) / sigSq; // exponent\n  let norm = 1 / (Math.sqrt(2 * Math.PI * sigSq)); // normalising factor\n  return norm * (Math.E ** exp);\n}\n\n// Information criteria functions below \nexport function AICc(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + ((6 * f * n) / (n - (3 * f) - 1))); \n}\n\nexport function AIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + (6 * f)); \n}\n\nexport function BIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (3 * f * Math.log(n) - (2 * totLogLik)); \n}\n\nexport function getGroups (tree: any, minCladeSize: number, numClocks: number): string[][][] {\n  // Sets of tips descending from each node\n  var tips: any = [];\n  // list tips descending from each node\n  tree.nodes.each((node: any) => tips.push(node.leaves())); \n  // map to just tip names\n  var tips = tips.map((e0: any) => e0.map((e1: any) => e1.data.name));\n  // De-duplicate tips (artefact from d3 hierarchy)\n  var uniqueTips = tips.map(\n    (e: string[]) => JSON.stringify(e)\n    ).filter(\n      (e: string[], i: number, a: string[][]) => {return a.indexOf(e) === i}\n      ).map(\n       (e: string) => JSON.parse(e)\n        )\n  // Sort clades based on size. Largest (all tips) goes first\n  var sortedUniqueTips = uniqueTips.sort((a: string[], b: string[]) => {return b.length - a.length});\n\n  // Filter out all clades with fewer than ${minCladeSize} tips\n  var finalClades = sortedUniqueTips.filter((e: string[]) => e.length >= minCladeSize);\n\n  // array from 1:(finalClades.length) possible clades to draw combinations\n  var grpNums = Array.from(Array(finalClades.length).keys());\n  // +1 to account for 0th base clock\n  //var grpNums = grpNums.map((e: number, i: number ) => i+1); \n  \n  // remove 0th group - that being all tips. Add back in later\n  grpNums.shift()\n  // get all combinations of groups to make up ${numClocks} local clocks\n  let comb = combn(grpNums, (numClocks - 1))\n  // add 0th clade for background rate\n  comb.map((e: number[]) => e.unshift(0)); \n\n  // Convert number combinations to corresponding groups of tips\n  let allGroups: string[][][] = [];\n  for (let i = 0; i < comb.length; i++){\n    allGroups.push(\n      comb[i].map(\n        (e: number) => finalClades[e]\n      )\n    );\n  }\n\n  //return groups after converting to non-intersecting groups;\n  return allGroups.map(e => getUnique(e));\n\n  // TODO: Size-filtering and defend against requesting too many clocks\n}\n\n// function takes string[][] and maps each to unique values assuming each string[] is nested as for allGroups\nexport function getUnique(x: string[][]): string[][] {\n  return x.map((e0: string[], i) => e0.filter(\n      (e1: string) => {\n        if(i+1 < x.length) { \n          return !x[i+1].includes(e1); \n        } else {\n          return true;\n        }\n      })\n  );\n}\n\n// A function that takes a list of tips and returns group number based on an element of allGroups\nfunction groupToNum(arr: string[][], tips: string[]): number[] {\n    let groupings: number[] = []; \n\n    for (let i = 0; i < tips.length; i++){\n      var tmp = [];\n      \n      for (let j = 0; j < arr.length; j++) {\n        if (arr[j].indexOf(tips[i]) > -1) {\n          groupings[i] = j;\n        } \n      }\n    }\n  return groupings;\n} // TODO: Include a test here to check that output is all integers and that ordering of tips matches input\n\n\n// generating combinations of groups\n export function combn(arr: any[], k: number): number[][] {\n  // Store all possible combinations in a result array\n  const result: number[][] = [];\n\n  // Generate all combinations using a recursive helper function\n  function generateCombinations(currentIndex: number, currentCombination: any[]): void {\n    // If the current combination has the desired length, add it to the result array\n    if (currentCombination.length === k) {\n      result.push(currentCombination);\n      return;\n    }\n\n    // Generate all possible combinations starting from the next element in the array\n    for (let i = currentIndex; i < arr.length; i++) {\n      generateCombinations(i + 1, currentCombination.concat(arr[i]));\n    }\n  }\n\n  // Start the recursive process with the first element in the array\n  generateCombinations(0, []);\n\n  // Return the result array\n  return result;\n}\n","const phylotree = require(\"phylotree\");\nconst _ = require(\"lodash\")\n\nexport const decimal_date = (date: Date) => {\n    var full_year = date.getFullYear();\n    var year_start = new Date(full_year, 0, 1).getTime(),\n        year_start_p1 = new Date(full_year + 1, 0, 1).getTime();\n\n    const decimal_date_value =\n        full_year + (date.getTime() - year_start) / (year_start_p1 - year_start);\n\n    return decimal_date_value;\n  };\n\nexport const createGroups = (decimal_dates:number[], tipHeights: number[], tipNames: number[], groupings:number[]) => {\n    /**\n     * Splits arrays into groups \n     * This method returns a array of group objects\n     */\n    let unique = groupings.filter((v, i, a) => a.indexOf(v) === i);\n    let groups = unique.map(() => {return {tipHeights:[] as number[], decimal_dates:[] as number[], tipNames: [] as number[]}})\n\n    for (let index = 0; index < groupings.length; index++) {\n      groups[groupings[index]].decimal_dates.push(\n        decimal_dates[index]\n      )\n      groups[groupings[index]].tipHeights.push(\n        tipHeights[index]\n      )\n      groups[groupings[index]].tipNames.push(\n        tipNames[index]\n      )\n    }\n    return groups\n  }\n\n  export const getTipHeights = (tree: any): number[] => {\n    // let tr = _.cloneDeep(tree)\n    // // map undefined BLs to zero:\n    // tr.nodes.each((n: any) => {\n    //   if (isNaN(n.data.attribute)) {\n    //     n.data.attribute =  '0';\n    //   } \n    //   if (isNaN(n.data.__mapped_bl)) {\n    //     n.data.__mapped_bl =  '0';\n    //   } \n    // });\n\n    // return (\n    //   tr.getTips().map((tip: any) => tip.data.rootToTip)[0] \n    //   ? \n    //   tr.getTips().map((tip: any) => tip.data.rootToTip)  \n    //   : \n    //   phylotree.rootToTip(tr).getTips().map((tip: any) => tip.data.rootToTip)\n    // )\n    phylotree.rootToTip(tree)\n    return tree.getTips().map((tip: any) => tip.data.rootToTip)\n  }\n\n  export const getTipNames = (tree: any): string[] => {\n    return tree.getTips().map((tip: any) => tip.data.name);\n  }\n","import { phylotree } from \"phylotree\";\nimport * as core from \"./core\";\nimport * as util from \"./utils\";\nvar minimize = require(\"minimize-golden-section-1d\");\n\nexport interface localOptima {\n  r2: number;\n  alpha: number;\n  nodeIndx: number;\n}\n\n/**\n * Creates a web worker for parallel processing and sets up message passing with the worker.\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @param {number[]} nodes - An array of node indices to be processed by the worker.\n * @returns {Promise} - A Promise that resolves with the worker's response data.\n */\nfunction createWorker(nwk: string, dates: number[], nodes: number[]) {\n  return new Promise(function (resolve, reject) {\n    const worker = new Worker(new URL(\"./bfrWorker.ts\", import.meta.url));\n    worker.postMessage({\n      nwk: nwk,\n      dates: dates,\n      nodeNums: nodes,\n    });\n    worker.onmessage = (e) => {\n      resolve(e.data);\n    };\n    worker.onerror = reject;\n  });\n}\n\n/**\n * Finds the best root for a phylogenetic tree by searching through all possible roots in parallel.\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @returns {Promise<string>} - A Promise that resolves with the Newick string of the best rooted tree.\n */\nexport async function globalRootParallel(nwk: string, dates: number[]) {\n  const tree = new phylotree(nwk);\n  var nodes = tree.nodes.descendants();\n  var nodeNums = nodes.map((e: any, i: number) => i).slice(1);\n\n  var nodeNumsChunked = spliceIntoChunks(\n    nodeNums,\n    (nodeNums.length - 1) / window.navigator.hardwareConcurrency\n  );\n\n  var promises = nodeNumsChunked.map((e: number[]) =>\n    createWorker(nwk, dates, e)\n  );\n\n  var prime = (await Promise.all(promises));\n\n  prime.unshift({\n    ...localRoot(tree, dates),\n    nodeIndx: 0,\n  });\n\n  var r2 = prime.map((e: any) => e.r2);\n\n  var bestR2 = Math.max(...r2);\n\n  var bestIndx = r2.indexOf(bestR2);\n  var best: any = prime[bestIndx];\n\n  let bestTree = new phylotree(nwk);\n\n  if (best.nodeIndx === 0) {\n    handleRootCase(bestTree, best);\n  } else {\n    handleNonRootCase(bestTree, tree, best);\n  }\n\n  return bestTree.getNewick();\n}\n\n/**\n * Handles the case when the best root found is already the root.\n *\n * @param {any} bestTree - The best rooted phylotree instance.\n * @param {any} best - The best local optima information.\n */\nfunction handleRootCase(bestTree: any, best: any) {\n  let bl = bestTree.getBranchLengths();\n  let len = bl[1] + bl[2];\n\n  bestTree.nodes.children[0].data.attribute = (best.alpha * len).toString();\n  bestTree.nodes.children[1].data.attribute = ((1 - best.alpha) * len).toString();\n}\n\n/**\n * Handles the case when the best root found is not the current root.\n *\n * @param {any} bestTree - The best rooted phylotree instance.\n * @param {any} tree - The original phylotree instance.\n * @param {any} best - The best local optima information.\n */\nfunction handleNonRootCase(bestTree: any, tree: any, best: any) {\n  bestTree.reroot(bestTree.nodes.descendants()[best.nodeIndx]);\n\n  let bl = bestTree.getBranchLengths();\n  let len = bl[1] + bl[2];\n\n  bestTree.nodes.children[0].data.attribute = (best.alpha * len).toString();\n  bestTree.nodes.children[1].data.attribute = ((1 - best.alpha) * len).toString();\n\n  bestTree.nodes.each((n: any) => {\n    if (n.data.__mapped_bl) {\n      n.data.attribute = n.data.__mapped_bl.toString();\n    }\n  });\n}\n\n/**\n * Finds the best local root for a given phylogenetic tree.\n *\n * @param {any} tree - A phylotree instance representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @returns {object} - An object containing the best alpha value and the corresponding R2 value.\n */\nexport function localRoot(tree: any, dates: number[]) {\n  var tipNames: string[] = util.getTipNames(tree);\n  var tipHeights: number[] = util.getTipHeights(tree);\n  var bl = tree.getBranchLengths();\n\n  var desc1: string[] = tree.nodes.children[0].leaves().map(\n    (e: any) => e.data.name\n  );\n\n  var indicator: number[] = [];\n  for (let i = 0; i < tipNames.length; i++) {\n    desc1.includes(tipNames[i]) ? indicator.push(1) : indicator.push(0);\n  }\n\n  let length = bl[1] + bl[2];\n\n  const univariateFunction = (x: number) => {\n    let tipHeightsNew = tipHeights.map(\n      (e, i) =>\n        indicator[i] * (e - bl[1] + x * length) +\n        (1 - indicator[i]) * (e - bl[2] + (1 - x) * length)\n    );\n    return -1 * core.linearRegression({ x: dates, y: tipHeightsNew, tip: tipNames }).r2;\n  };\n\n  let alpha = minimize(univariateFunction, { lowerBound: 0, upperBound: 1 });\n  return { alpha: alpha, r2: -1 * univariateFunction(alpha) };\n}\n\ninterface TipIndices {\n  [key: string]: number;\n}\n\n/**\n * Reorders an array of data based on the correspondence between the current and target tip names.\n *\n * @param {number[]} arr - The array of data to be reordered.\n * @param {string[]} currentTip - An array of the current tip names.\n * @param {string[]} targetTip - An array of the target tip names.\n * @returns {number[]} - The reordered array of data.\n */\nexport function reorderData(arr: number[], currentTip: string[], targetTip: string[]) {\n  const targetTipIndices: TipIndices = {};\n  for (let i = 0; i < targetTip.length; i++) {\n    targetTipIndices[targetTip[i]] = i;\n  }\n\n  const arrOrdered = currentTip.map((tip) => {\n    const index = targetTipIndices[tip];\n    return arr[index];\n  });\n\n  return arrOrdered;\n}\n\n/**\n * Splits an array into chunks of the specified size.\n *\n * @param {number[]} arr - The array to be split into chunks.\n * @param {number} chunkSize - The size of each chunk.\n * @returns {number[][]} - An array of chunks.\n */\nfunction spliceIntoChunks(arr: number[], chunkSize: number) {\n  const res = [];\n  while (arr.length > 0) {\n    const chunk = arr.splice(0, chunkSize);\n    res.push(chunk);\n  }\n  return res;\n}","import { phylotree } from \"phylotree\";\nimport { localRoot, localOptima, reorderData } from \"./bestFittingRoot\";\n\n// this runs on the webworker, created with webpack 5 syntax new\n// Worker('./worker.ts'). in jest tests, this module is not used, instead the\n// workerMessageHandler is directly addressed\nself.onmessage = ({ data: { nwk, dates, nodeNums } }) => { /* eslint-disable-line no-restricted-globals */\n  var tree = new phylotree(nwk)\n  var treePrime: any = {}\n  var datesPrime: number[] = []\n  var localOptimum: localOptima\n  var best: localOptima\n\n  // first node case\n  treePrime = new phylotree(nwk);\n  treePrime.reroot(treePrime.nodes.descendants()[nodeNums[0]]);\n  // set branch lengths\n  treePrime.nodes.each((n: any) => {\n    if (n.data.__mapped_bl){\n      n.data.attribute = n.data.__mapped_bl.toString();\n    }\n  })\n\n  datesPrime = reorderData(\n    dates,\n    tree.getTips().map((e: any) => e.data.name),\n    treePrime.getTips().map((e: any) => e.data.name)\n  )\n\n  best = {\n    ...localRoot(\n      treePrime,\n      datesPrime\n    ),\n    nodeIndx: nodeNums[0]\n    }\n\n  // compare to rest of nodes\n  for (let i=1; i<nodeNums.length; i++) {\n    treePrime = new phylotree(nwk);\n    treePrime.reroot(treePrime.nodes.descendants()[nodeNums[i]]);\n    // set branch lengths\n    treePrime.nodes.each((n: any) => {\n      if (n.data.__mapped_bl){\n        n.data.attribute = n.data.__mapped_bl.toString();\n      }\n    })\n\n    datesPrime = reorderData(\n      dates,\n      tree.getTips().map((e: any) => e.data.name),\n      treePrime.getTips().map((e: any) => e.data.name)\n    )\n\n    localOptimum = {\n      ...localRoot(\n        treePrime,\n        datesPrime\n      ),\n      nodeIndx: nodeNums[i]\n    }\n\n    if (localOptimum.r2 - best.r2 > 1e-08) {\n      best = localOptimum;\n    }\n  }\n\n  self.postMessage(best); /* eslint-disable-line no-restricted-globals */\n}; ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [805,492], function() { return __webpack_require__(74245); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"245\":\"cea147e7\",\"492\":\"3c738e0a\",\"805\":\"d86e3fb0\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t245: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkclockor2\"] = self[\"webpackChunkclockor2\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([\n\t\t__webpack_require__.e(805),\n\t\t__webpack_require__.e(492)\n\t]).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["require","linearRegression","points","reg","tip","x","y","n","length","sum_x","sum_y","sum_xy","sum_xx","sum_yy","j","slope","intercept","fitY","map","e","r2","Math","pow","sqrt","sigSq","i","a","reduce","b","logLik","log","mu","exp","PI","E","normalDensity","phylotree","minimize","localRoot","tree","dates","tipNames","getTips","data","name","util","tipHeights","rootToTip","bl","getBranchLengths","desc1","nodes","children","leaves","indicator","includes","push","univariateFunction","tipHeightsNew","core","alpha","lowerBound","upperBound","reorderData","arr","currentTip","targetTip","targetTipIndices","index","self","onmessage","localOptimum","best","nwk","nodeNums","treePrime","datesPrime","reroot","descendants","each","__mapped_bl","attribute","toString","nodeIndx","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","every","key","splice","r","d","definition","o","defineProperty","enumerable","get","f","chunkId","Promise","all","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","value","nmd","paths","p","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}