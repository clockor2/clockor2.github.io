{"version":3,"file":"static/js/907.d2aa964a.chunk.js","mappings":"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","sources":["features/engine/core.ts","features/engine/utils.ts","features/engine/clockSearch.ts","features/engine/clockSearchWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["// eslint-disable-next-line \n\n\nimport {phylotree, rootToTip} from \"phylotree\" // for clock search TODO: Add best fitting root soon!\n// import { group } from \"console\";\n// import { maxHeaderSize } from \"http\";\n\nconst chroma = require(\"chroma-js\") // TODO: Learn about why this works instead of import\n\n// class to contain local clock model, incl. data points and information criteria\nexport interface LocalClockModel {\n  baseClock: Regression;\n  localClock: Regression[];\n  baseIC: InfoMetric;\n  localIC: InfoMetric;\n}\n// interface for info metric data\ninterface InfoMetric {\n  aic: number;\n  aicc: number;\n  bic: number;\n}\n\n// function to make plottable points\n// method for plotly plotting\nexport function plotify(lcm: LocalClockModel | null): Plotly.Data[] | null {\n  const plot = [] as Plotly.Data[];\n  if (lcm != null) {\n    // generate colour scale. Use viridis-ish default\n    const cols = chroma.scale(['#fafa6e', '#2A4858']).mode('lch').colors(lcm.localClock.length); // move this to state\n    // Pushing plotly object for base lock\n    var point = {\n      x: lcm.baseClock.x,\n      y: lcm.baseClock.y,\n      text: lcm.baseClock.tip,\n      marker: {color: '#000000', size: 5},\n      mode: \"markers\",\n      name: \"Global\",\n      legendgroup: \"0\",\n      showlegend: false\n    }\n    plot.push(point);\n\n    var line = {\n      x: lcm.baseClock.x,\n      y: lcm.baseClock.fitY,\n      name: `Global`,\n      marker : {color: '#000000'},\n      mode: \"lines\",\n      text: lcm.localClock.length > 1 \n      ? \n        `Baseline<br>R2: ${lcm.baseClock.r2.toFixed(2)}` \n      : \n        `R2: ${lcm.baseClock.r2.toFixed(2)}`,\n\n      legendgroup: \"0\"\n    }\n    plot.push(line);\n\n    // pushing plotly object for each local clock\n    for (let i = 0; i < lcm.localClock.length; i++) {\n      var point1 = {\n        x: lcm.localClock[i].x,\n        y: lcm.localClock[i].y,\n        text: lcm.localClock[i].tip,\n        marker: {color: cols[i]},\n        mode: \"markers\",\n        legendgroup: `${i + 1}`,\n        showlegend: false\n      }\n      plot.push(point1);\n\n      var line1 = {\n        x: lcm.localClock[i].x,\n        y: lcm.localClock[i].fitY,\n        text: `Local Clock: ${i + 1}<br>R2: ${lcm.localClock[i].r2.toFixed(2)}`,\n        marker : {color: cols[i]},\n        mode: \"lines\",\n        legendgroup: `${i + 1}`,\n        name: `Local Clock ${i + 1}`\n      }\n      plot.push(line1);\n    }\n      return plot;\n  } else {\n    return null;\n  }\n  }\n\n\n\ninterface Style {\n  color: string;\n}\n\n// Class to pass back to plot later. Will be produced by plotify method in \n// flcModel class\n// interface Data extends Plotly.PlotData {\n//   color: string\n// }\n\n// class regression for storing the points, r^2, slope, fit for a set of points x, y\n// inferface for ouput of regression functions\nexport interface Regression {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  fitY: Array<number>;\n  slope: number;\n  intercept: number;\n  sigSq: number;\n  r2: number;\n  logLik: number;\n}\n\n// Groups of points pertaining to one local clock\n// To be apended in array for linearRegression()\ninterface DataGroup {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n}\n\n//////////////////////////////////////////////////////\n// BELOW: CORE ENGINE FUNCTIONS SUCH AS SOMETHING() //\n// INCORPORATE FUNCTIONS DEFINED BELOW              //\n//////////////////////////////////////////////////////\n\n// Core function. Functionality for groups to be added\nexport const regression = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings: Array<number>,\n  tipNames: Array<string>) => {\n\n  var dataPoints = groupData(tipHeights, dates, groupings, tipNames);\n\n  var lcm = {} as LocalClockModel;\n  \n  lcm.baseClock = linearRegression(dataPoints[0]);\n  lcm.baseIC = {} as InfoMetric;\n  lcm.baseIC.aic = AIC([lcm.baseClock]);\n  lcm.baseIC.aicc = AICc([lcm.baseClock]);\n  lcm.baseIC.bic = BIC([lcm.baseClock]);\n\n  lcm.localClock = dataPoints.slice(1).map(e => linearRegression(e));\n  lcm.localIC = {} as InfoMetric;\n  lcm.localIC.aic = AIC(lcm.localClock);\n  lcm.localIC.aicc = AICc(lcm.localClock);\n  lcm.localIC.bic = BIC(lcm.localClock);\n  \n  return lcm;\n}\n\n// Clock search function. Conver to a generator later\n// icMetric is the information criterion used to find 'best' state. TODO: Need to read these as part of input: aic | aicc | bic\n// export const clockSearch = (tree: any,\n//   minCladeSize: number,\n//   numClocks: number,\n//   tipHeights: Array<number>,\n//   dates: Array<number>,\n//   tipNames: Array<string>,\n//   icMetric: string) => {\n\n//   // generate all possibilities for groupings\n//   let allGroups = getGroups(tree, minCladeSize, numClocks);\n//   let allGroupsNumber = allGroups.map((e: string[][]) => groupToNum(e, tips));\n\n//   // Loop through group possibilities and append to fits\n//   let fits: LocalClockModel[] = [];\n//   for (let i = 0; i < allGroups.length; i++){\n//       fits.push(regression(tipHeights, dates, allGroups[i], tipNames)); \n//   }\n\n//   // Now find the most supported configuration\n//   // Getting array of IC values based on selected IC TODO: Add capability for multiple ICs\n//   const ic = fits.map(e => e[icMetric as keyof LocalClockModel]) // TODO: Test here!\n\n//   var icMaxStep = ic.indexOf(Math.max(...(ic as number[]))); // TODO: This might throw an error if we never see output\n\n//   return fits[icMaxStep];\n// }\n\n////////////////////////////////////////////////////////\n// BELOW: FUNCTIONS USED INSIDE CORE ENGINE FUNCTIONS //\n////////////////////////////////////////////////////////\n\n// function groups points for local clock regresion\n// 0th element of array is always points for single clock\nconst groupData = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings: Array<number>,\n  tipNames: Array<string>\n  ): DataGroup[] => { \n  \n  let unique = groupings.filter((v, i, a) => a.indexOf(v) === i);\n\n  const points: DataGroup[] = [];\n\n  for (let i = 0; i < unique.length; i++) {\n    var tmp: DataGroup = {x: [], y: [], tip: []};\n    points.push(tmp);\n  }\n\n  for (let i = 0; i < groupings.length; i++) {\n    points[groupings[i]].x.push(\n      dates[i]\n    )\n    points[groupings[i]].y.push(\n      tipHeights[i]\n    )\n    points[groupings[i]].tip.push(\n      tipNames[i]\n    )\n  }\n  // if  num groups > 1, append the baseline fit (all points in one group)\n  // In the case num groups = 1, this is automatically appended\n  if (unique.length > 1) {\n    points.unshift({\n      x: dates,\n      y: tipHeights,\n      tip: tipNames\n    })}\n\n  return points;\n}\n\n// regression function \nexport function linearRegression(points: DataGroup) {\n  const reg = {} as Regression;\n\n  // carrying tips over first\n  reg.tip = points.tip;\n\n  let x = points.x;\n  let y = points.y;\n\n  var n = y.length;\n  var sum_x = 0;\n  var sum_y = 0;\n  var sum_xy = 0;\n  var sum_xx = 0;\n  var sum_yy = 0;\n\n  for (let j = 0; j < y.length; j++) {\n      sum_x += x[j];\n      sum_y += y[j];\n      sum_xy += (x[j]*y[j]);\n      sum_xx += (x[j]*x[j]);\n      sum_yy += (y[j]*y[j]);\n  } \n\n  // Include these later after agreeing on how to pass to front end\n  reg.x = x;\n  reg.y = y;\n  reg.slope = (n * sum_xy - sum_x * sum_y) / (n*sum_xx - sum_x * sum_x);\n  reg.intercept = (sum_y - reg.slope * sum_x)/n;\n  reg.fitY = x.map(e => (reg.slope * e + reg.intercept));\n  reg.r2 = Math.pow((n*sum_xy - sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);\n  //calculate log likelihood\n  \n  let error = y.map((n, i, a) => y[i] - reg.fitY[i]); \n  // estiamted variance of error\n  let sigSq = error.map(n => Math.pow(n, 2)).reduce(\n    (a, b) => a + b, 0) * (1 / reg.fitY.length);\n  //reg.logLik = y.map((e, i) => Math.log(normalDensity(e, reg.fitY[i], sigSq))).reduce((a, b) => a + b); \n  reg.logLik = y.map((e, i) => Math.log(\n    normalDensity(e, reg.fitY[i], sigSq)\n    )\n    ).reduce(\n      (a, b) => a + b\n      ); \n\n  return reg;\n}\n\n// Function for likelihood in linearRegression() function\n export function normalDensity(y: number, mu: number, sigSq: number) {\n  let exp = -0.5 * ((y - mu) ** 2) / sigSq; // exponent\n  let norm = 1 / (Math.sqrt(2 * Math.PI * sigSq)); // normalising factor\n  return norm * (Math.E ** exp);\n}\n\n// Information criteria functions below \nexport function AICc(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + ((6 * f * n) / (n - (3 * f) - 1))); \n}\n\nexport function AIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + (6 * f)); \n}\n\nexport function BIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (3 * f * Math.log(n) - (2 * totLogLik)); \n}\n\nexport function getGroups (tree: any, minCladeSize: number, numClocks: number): string[][][] {\n  // Sets of tips descending from each node\n  var tips: any = [];\n  // list tips descending from each node\n  tree.nodes.each((node: any) => tips.push(node.leaves())); \n  // map to just tip names\n  var tips = tips.map((e0: any) => e0.map((e1: any) => e1.data.name));\n  // De-duplicate tips (artefact from d3 hierarchy)\n  var uniqueTips = tips.map(\n    (e: string[]) => JSON.stringify(e)\n    ).filter(\n      (e: string[], i: number, a: string[][]) => {return a.indexOf(e) === i}\n      ).map(\n       (e: string) => JSON.parse(e)\n        )\n  // Sort clades based on size. Largest (all tips) goes first\n  var sortedUniqueTips = uniqueTips.sort((a: string[], b: string[]) => {return b.length - a.length});\n\n  // Filter out all clades with fewer than ${minCladeSize} tips\n  var finalClades = sortedUniqueTips.filter((e: string[]) => e.length >= minCladeSize);\n\n  // array from 1:(finalClades.length) possible clades to draw combinations\n  var grpNums = Array.from(Array(finalClades.length).keys());\n  // +1 to account for 0th base clock\n  //var grpNums = grpNums.map((e: number, i: number ) => i+1); \n  \n  // remove 0th group - that being all tips. Add back in later\n  grpNums.shift()\n  // get all combinations of groups to make up ${numClocks} local clocks\n  let comb = combn(grpNums, (numClocks - 1))\n  // add 0th clade for background rate\n  comb.map((e: number[]) => e.unshift(0)); \n\n  // Convert number combinations to corresponding groups of tips\n  let allGroups: string[][][] = [];\n  for (let i = 0; i < comb.length; i++){\n    allGroups.push(\n      comb[i].map(\n        (e: number) => finalClades[e]\n      )\n    );\n  }\n\n  //return groups after converting to non-intersecting groups;\n  return allGroups.map(e => getUnique(e));\n\n  // TODO: Size-filtering and defend against requesting too many clocks\n}\n\n// function takes string[][] and maps each to unique values assuming each string[] is nested as for allGroups\nexport function getUnique(x: string[][]): string[][] {\n  return x.map((e0: string[], i) => e0.filter(\n      (e1: string) => {\n        if(i+1 < x.length) { \n          return !x[i+1].includes(e1); \n        } else {\n          return true;\n        }\n      })\n  );\n}\n\n// A function that takes a list of tips and returns group number based on an element of allGroups\nfunction groupToNum(arr: string[][], tips: string[]): number[] {\n    let groupings: number[] = []; \n\n    for (let i = 0; i < tips.length; i++){\n      var tmp = [];\n      \n      for (let j = 0; j < arr.length; j++) {\n        if (arr[j].indexOf(tips[i]) > -1) {\n          groupings[i] = j;\n        } \n      }\n    }\n  return groupings;\n} // TODO: Include a test here to check that output is all integers and that ordering of tips matches input\n\n\n// generating combinations of groups\n export function combn(arr: any[], k: number): number[][] {\n  // Store all possible combinations in a result array\n  const result: number[][] = [];\n\n  // Generate all combinations using a recursive helper function\n  function generateCombinations(currentIndex: number, currentCombination: any[]): void {\n    // If the current combination has the desired length, add it to the result array\n    if (currentCombination.length === k) {\n      result.push(currentCombination);\n      return;\n    }\n\n    // Generate all possible combinations starting from the next element in the array\n    for (let i = currentIndex; i < arr.length; i++) {\n      generateCombinations(i + 1, currentCombination.concat(arr[i]));\n    }\n  }\n\n  // Start the recursive process with the first element in the array\n  generateCombinations(0, []);\n\n  // Return the result array\n  return result;\n}\n","const phylotree = require(\"phylotree\");\nconst _ = require(\"lodash\")\n\nexport const decimal_date = (date: Date) => {\n    var full_year = date.getFullYear();\n    var year_start = new Date(full_year, 0, 1).getTime(),\n        year_start_p1 = new Date(full_year + 1, 0, 1).getTime();\n\n    const decimal_date_value =\n        full_year + (date.getTime() - year_start) / (year_start_p1 - year_start);\n\n    return decimal_date_value;\n  };\n\nexport const createGroups = (decimal_dates:number[], tipHeights: number[], tipNames: number[], groupings:number[]) => {\n    /**\n     * Splits arrays into groups \n     * This method returns a array of group objects\n     */\n    let unique = groupings.filter((v, i, a) => a.indexOf(v) === i);\n    let groups = unique.map(() => {return {tipHeights:[] as number[], decimal_dates:[] as number[], tipNames: [] as number[]}})\n\n    for (let index = 0; index < groupings.length; index++) {\n      groups[groupings[index]].decimal_dates.push(\n        decimal_dates[index]\n      )\n      groups[groupings[index]].tipHeights.push(\n        tipHeights[index]\n      )\n      groups[groupings[index]].tipNames.push(\n        tipNames[index]\n      )\n    }\n    return groups\n  }\n\n  export const getTipHeights = (tree: any): number[] => {\n    // let tr = _.cloneDeep(tree)\n    // // map undefined BLs to zero:\n    // tr.nodes.each((n: any) => {\n    //   if (isNaN(n.data.attribute)) {\n    //     n.data.attribute =  '0';\n    //   } \n    //   if (isNaN(n.data.__mapped_bl)) {\n    //     n.data.__mapped_bl =  '0';\n    //   } \n    // });\n\n    // return (\n    //   tr.getTips().map((tip: any) => tip.data.rootToTip)[0] \n    //   ? \n    //   tr.getTips().map((tip: any) => tip.data.rootToTip)  \n    //   : \n    //   phylotree.rootToTip(tr).getTips().map((tip: any) => tip.data.rootToTip)\n    // )\n    phylotree.rootToTip(tree)\n    return tree.getTips().map((tip: any) => tip.data.rootToTip)\n  }\n\n  export const getTipNames = (tree: any): string[] => {\n    return tree.getTips().map((tip: any) => tip.data.name);\n  }\n","import { phylotree } from \"phylotree\" \nimport { regression, LocalClockModel } from \"./core\"\nimport { getTipHeights, getTipNames } from \"./utils\"\n\n/**\n * Creates a web worker for clock search in background thread\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number} minCladeSize - Minimum group size for search\n * @param {number} maxClocks - Max clocks to search for. Searches for 1..maxClocks\n * @param {number[]} dates - Tip dates\n * @param {\"aic\" | \"aicc\" | \"bic\"} icMetric - Information criterion used to determine best config. BIC reccommened.\n * @returns {Promise} - A Promise that resolves with the worker's response data.\n */\nexport function createClockSearchWorker(\n  nwk: string, \n  minCladeSize: number,\n  maxClocks: number,\n  dates: number[], \n  icMetric: \"aic\" | \"aicc\" | \"bic\"\n  ): Promise<LocalClockModel> {\n  return new Promise(function (resolve, reject) {\n    const worker = new Worker(new URL(\"./clockSearchWorker.ts\", import.meta.url));\n    worker.postMessage({\n      nwk: nwk, \n      minCladeSize: minCladeSize,\n      maxClocks: maxClocks,\n      dates: dates, \n      icMetric: icMetric\n    });\n    worker.onmessage = (e) => {\n      resolve(e.data);\n    };\n    worker.onerror = reject;\n  });\n}\n\n// Clock search function. Conver to a generator later\n// icMetric is the information criterion used to find 'best' state. TODO: Need to read these as part of input: aic | aicc | bic\nexport const clockSearch = (\n    nwk: string,\n    minCladeSize: number,\n    maxClocks: number,\n    dates: Array<number>,\n    icMetric: \"aic\" | \"aicc\" | \"bic\"\n    ) => {\n  \n    var tree = new phylotree(nwk)\n    \n    var allGroups: string[][][] = [];\n    for (let i = 1; i <= maxClocks; i++) {\n        allGroups = allGroups.concat(\n            getGroups(\n                tree,\n                minCladeSize,\n                i\n            ))\n    }\n    // converting to group string\n    var allTips = tree.getTips().map((e: any) => e.data.name)\n\n    // error for too many clocks\n    const error = Error(`Too may clocks for minimum clade size. Spurious results await`)\n    if (maxClocks > Math.floor(allTips.length / minCladeSize) ){\n      console.error(error.message)\n    } \n\n\n    var groupsNumbered = allGroups.map(\n      (e:string[][]) => makeGroups(\n        allTips, \n        e)\n    )\n\n    var tipNames = getTipNames(tree);\n    var tipHeights = getTipHeights(tree);\n    \n    var fits: LocalClockModel[] = [];\n    for (let i = 0; i < allGroups.length; i++){\n        fits.push(\n            regression(\n                tipHeights,\n                dates,//TODO: is dates in the right order? - keep in state?\n                groupsNumbered[i],\n                tipNames\n                )\n            );     \n    }\n\n    // Now find the most supported configuration. Want baseIC iff only one group\n    var ic: number[] = fits.map(\n        e => e.localClock.length > 1 ? e.localIC[icMetric] : e.baseIC[icMetric]\n        );\n\n    var minIC = Math.min(...ic); \n\n    var indexBest = ic.indexOf(minIC);\n    return fits[indexBest];\n  }\n  \n  export function getGroups (tree: any, minGroupSize: number, numClocks: number): string[][][] {\n    var tipNodes = tree.getInternals().map((e: any) => e.leaves())\n\n    // TODO: Throw error if numClocks > nTips / minGroupSize. Needs Parse Int\n\n    var tips = tipNodes.map(\n      (e: any) => e.map((e1: any) => e1.data.name)\n      ).sort(\n        (a: string[], b: string[]) => {return b.length - a.length}\n      ).filter(\n        (e: string[]) => e.length >= minGroupSize\n      );\n  \n    // [1,...,tips.length] as array for combn()\n    let nums = [...Array(tips.length)].map((e, i) => i).slice(1);\n\n    var combinations: number[][] = combn(nums, (numClocks - 1));\n    \n    // return 0th clade for background rate, sort, and find unique\n    combinations.map(\n        (e: number[]) => e.unshift(0)\n        )\n\n    // Convert number combinations to corresponding groups of tips\n    var allGroups: string[][][] = [];\n    var tmp: string[][] = []\n    for (let i = 0; i < combinations.length; i++){\n      tmp = combinations[i].map(\n        (e: number) => tips[e]\n      )\n      allGroups.push(tmp);\n    }\n\n    allGroups = allGroups.map(e => unNest(e))\n    // allGroups = allGroups.map(e => e.sort()) // sorting for testing\n    \n    // Filter out all groups with fewer than ${minCladeSize} tips\n    var finalGroups = allGroups.filter(\n      (e0: string[][]) => !(\n        e0.some(\n          (e1: string[]) => e1.length < minGroupSize\n        )\n      ) \n    );\n\n    // de-duplicating\n    finalGroups = finalGroups.map(\n      e => JSON.stringify(e)\n    ).filter(\n      (v,i,a)=>a.indexOf(v)===i\n    ).map(\n      e => JSON.parse(e)\n    )\n\n    return finalGroups;\n\n  }\n\n// Make groups into a 1D array of numbers coresponding to tips. TODO: test\nexport function makeGroups(tips: string[], nestedGrp: string[][]): number[] {\n let grp: number[] = []\n\n for (let i=0; i<tips.length; i++){\n  for (let j=nestedGrp.length-1; j>=0; j--){\n\n    if (nestedGrp[j].includes(tips[i])){\n      grp.push(j)\n      break\n    } \n  \n  }\n }\n\n return grp;\n}\n\n  \n  // Un-nests group membership\n  export function unNest(arr: string[][]): string[][] {\n    var unNested: string[][] = [];\n\n    unNested[arr.length-1] = arr[arr.length-1];\n    for (let i = arr.length-2; i>=0; i--){\n      unNested[i] = arr[i].filter(\n        (e: string) => !arr.slice(i+1).flat().includes(e)\n      )\n    }\n    return unNested.sort();\n  }\n  \n  // generating combinations of groups\n   export function combn(arr: any[], k: number): number[][] {\n    // Store all possible combinations in a result array\n    const result: number[][] = [];\n  \n    // Generate all combinations using a recursive helper function\n    function generateCombinations(currentIndex: number, currentCombination: any[]): void {\n      // If the current combination has the desired length, add it to the result array\n      if (currentCombination.length === k) {\n        result.push(currentCombination);\n        return;\n      }\n  \n      // Generate all possible combinations starting from the next element in the array\n      for (let i = currentIndex; i < arr.length; i++) {\n        generateCombinations(i + 1, currentCombination.concat(arr[i]));\n      }\n    }\n  \n    // Start the recursive process with the first element in the array\n    generateCombinations(0, []);\n  \n    // Return the result array\n    return result;\n  }\n  ","import { clockSearch } from \"./clockSearch\";\n\n// this runs on the webworker, created with webpack 5 syntax new\n// Worker('./worker.ts'). in jest tests, this module is not used, instead the\n// workerMessageHandler is directly addressed\nself.onmessage = ( /* eslint-disable-line no-restricted-globals */\n  { \n    data: { \n      nwk,\n      minCladeSize,\n      maxClocks,\n      dates,\n      icMetric  \n    } \n  }\n) => { /* eslint-disable-line no-restricted-globals */\n \n  let bestGrpConfig = clockSearch(\n      nwk,\n      minCladeSize,\n      maxClocks,\n      dates,\n      icMetric\n    )\n  \n  self.postMessage(bestGrpConfig); /* eslint-disable-line no-restricted-globals */\n}; ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [805,928], function() { return __webpack_require__(51907); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"805\":\"d86e3fb0\",\"907\":\"d2aa964a\",\"928\":\"3c46870c\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t907: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkclockor2\"] = self[\"webpackChunkclockor2\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([\n\t\t__webpack_require__.e(805),\n\t\t__webpack_require__.e(928)\n\t]).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["require","regression","tipHeights","dates","groupings","tipNames","dataPoints","groupData","lcm","baseClock","linearRegression","baseIC","aic","AIC","aicc","AICc","bic","BIC","localClock","slice","map","e","localIC","unique","filter","v","i","a","indexOf","points","length","push","x","y","tip","unshift","reg","n","sum_x","sum_y","sum_xy","sum_xx","sum_yy","j","slope","intercept","fitY","r2","Math","pow","sqrt","sigSq","reduce","b","logLik","log","mu","exp","PI","E","normalDensity","regs","f","totLogLik","phylotree","clockSearch","nwk","minCladeSize","maxClocks","icMetric","tree","allGroups","concat","getGroups","allTips","getTips","data","name","error","Error","floor","console","message","groupsNumbered","tips","nestedGrp","grp","includes","makeGroups","getTipNames","rootToTip","getTipHeights","fits","ic","minIC","min","minGroupSize","numClocks","getInternals","leaves","e1","sort","nums","Array","combinations","arr","k","result","generateCombinations","currentIndex","currentCombination","combn","tmp","unNested","flat","unNest","finalGroups","e0","some","JSON","stringify","parse","self","onmessage","bestGrpConfig","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","every","key","splice","r","d","definition","o","defineProperty","enumerable","get","chunkId","Promise","all","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","value","nmd","paths","children","p","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}