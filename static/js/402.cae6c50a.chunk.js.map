{"version":3,"file":"static/js/402.cae6c50a.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","features/engine/core.ts","features/engine/clockSearch.ts","features/engine/clockSearchWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import { date_decimal } from \"./utils\";\nconst chroma = require(\"chroma-js\") // TODO: Learn about why this works instead of import\n\n// class to contain local clock model, incl. data points and information criteria\nexport interface LocalClockModel {\n  baseClock: Regression;\n  localClock: Regression[];\n  baseIC: InfoMetric;\n  localIC: InfoMetric;\n  groupNames: string[];\n}\n// interface for info metric data\nexport interface InfoMetric {\n  aic: number;\n  aicc: number;\n  bic: number;\n}\n\n// function to make plottable points\n// method for plotly plotting\nexport function plotify(lcm: LocalClockModel | null): any[] | null {\n  const plot = [] as any[];\n  if (lcm != null) {\n    // generate colour scale. Use viridis-ish default\n    const cols = lcm.localClock !== undefined\n      ?\n      chroma.scale(['#fafa6e', '#2A4858']).mode('lch').colors(lcm.localClock.length)\n      :\n      \"DarkSlateGrey\";\n\n    // Pushing plotly object for base lock\n    var point = {\n      x: lcm.baseClock.x.map(e => date_decimal(e)),\n      y: lcm.baseClock.y,\n      text: lcm.baseClock.tip,\n      marker: {color: '#000000', size: 7},\n      mode: \"markers\",\n      name: \"Global\",\n      legendgroup: \"Global\",\n      showlegend: false,\n      type: \"scattergl\"\n    }\n    plot.push(point);\n\n    var line = {\n      x: lcm.baseClock.x.map(e => date_decimal(e)),\n      y: lcm.baseClock.fitY,\n      name: \"Global\",\n      marker : {color: '#000000'},\n      mode: \"lines\",\n      text: lcm.localClock\n      ? \n        `Global<br>R2: ${lcm.baseClock.r2.toFixed(2)}` \n      : \n        `R2: ${lcm.baseClock.r2.toFixed(2)}`,\n\n      legendgroup: \"Global\",\n      type: \"scattergl\"\n    }\n    plot.push(line);\n\n    // pushing plotly object for each local clock\n    if (lcm.localClock){\n      for (let i = 0; i < lcm.localClock.length; i++) {\n        let legendGroup\n        if (lcm.groupNames[i+1] !== undefined) {\n          legendGroup = lcm.groupNames[i+1].length > 1 ? lcm.groupNames[i+1] : `Local Clock ${i+1}`\n        } else {\n          legendGroup = `Local Clock ${i+1}`;\n        }\n        \n        var point1 = {\n          x: lcm.localClock[i].x.map(e => date_decimal(e)),\n          y: lcm.localClock[i].y,\n          text: lcm.localClock[i].tip,\n          marker: {color: cols[i], line: {width: 1, color: 'DarkSlateGrey'}},\n          mode: \"markers\",\n          legendgroup: legendGroup,\n          name: lcm.groupNames[i+1],\n          showlegend: false,\n          type: \"scattergl\"\n        }\n        plot.push(point1);\n\n        var line1 = {\n          x: lcm.localClock[i].x.map(e => date_decimal(e)),\n          y: lcm.localClock[i].fitY,\n          text: `${lcm.groupNames[i+1] ?? `Local Clock ${i+1}`}<br>R2: ${lcm.localClock[i].r2.toFixed(2)}`,\n          marker : {color: cols[i], line: {width: 1, color: 'DarkSlateGrey'}},\n          mode: \"lines\",\n          legendgroup: legendGroup,\n          name: lcm.groupNames[i+1],\n          type: \"scattergl\"\n        }\n        plot.push(line1);\n      }\n    }\n      return plot;\n  } else {\n    return null;\n  }\n}\n\nexport interface Regression {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  fitY: Array<number>;\n  slope: number;\n  intercept: number;\n  sigSq: number;\n  r2: number;\n  logLik: number;\n  rms: number;\n}\n\n// Groups of points pertaining to one local clock\n// To be apended in array for linearRegression()\ninterface DataGroup {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  name: string;\n}\n\n//////////////////////////////////////////////////////\n// BELOW: CORE ENGINE FUNCTIONS SUCH AS SOMETHING() //\n// INCORPORATE FUNCTIONS DEFINED BELOW              //\n//////////////////////////////////////////////////////\n\n// Core function. Functionality for groups to be added\nexport const regression = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings: Array<string>,\n  tipNames: Array<string>) => {\n\n  var dataPoints = groupData(tipHeights, dates, groupings, tipNames);\n\n  var lcm = {} as LocalClockModel;\n  \n  lcm.baseClock = linearRegression(dataPoints[0]);\n  lcm.baseIC = {} as InfoMetric;\n  lcm.baseIC.aic = AIC([lcm.baseClock]);\n  lcm.baseIC.aicc = AICc([lcm.baseClock]);\n  lcm.baseIC.bic = BIC([lcm.baseClock]);\n\n  if (dataPoints.length > 1) {\n    lcm.localClock = dataPoints.slice(1).map(e => linearRegression(e));\n    lcm.localIC = {} as InfoMetric;\n    lcm.localIC.aic = AIC(lcm.localClock);\n    lcm.localIC.aicc = AICc(lcm.localClock);\n    lcm.localIC.bic = BIC(lcm.localClock);\n  }\n\n  lcm.groupNames = dataPoints.map(e => e.name)\n  \n  return lcm;\n}\n\n////////////////////////////////////////////////////////\n// BELOW: FUNCTIONS USED INSIDE CORE ENGINE FUNCTIONS //\n////////////////////////////////////////////////////////\n\n// function groups points for local clock regresion\n// 0th element of array is always points for single clock\nexport const groupData = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings:  Array<string>,\n  tipNames: Array<string>\n  ): DataGroup[] => { \n\n  const points: DataGroup[] = [];\n\n  let unique = groupings.filter((v, i, a) => a.indexOf(v) === i).sort();\n  let numericGroupings =  groupings.map(group => unique.indexOf(group))\n\n  for (let i = 0; i < unique.length; i++) {\n    var tmp: DataGroup = {x: [], y: [], tip: [], name: unique[i]};\n    points.push(tmp);\n  }\n\n  for (let i = 0; i < groupings.length; i++) {\n    points[numericGroupings[i]].x.push(\n      dates[i]\n    )\n    points[numericGroupings[i]].y.push(\n      tipHeights[i]\n    )\n    points[numericGroupings[i]].tip.push(\n      tipNames[i]\n    )\n  }\n  // if  num groups > 1, append the baseline fit (all points in one group)\n  // In the case num groups = 1, this is automatically appended\n  if (unique.length > 1) {\n    points.unshift({\n      x: dates,\n      y: tipHeights,\n      tip: tipNames,\n      name: \"Global\"\n    })}\n\n  return points;\n}\n\n// regression function \nexport function linearRegression(points: DataGroup) {\n  let reg = {} as Regression;\n\n  reg.tip = points.tip;\n\n  let x = points.x;\n  let y = points.y;\n\n  let sum_x = 0;\n  let n = y.length;\n  let sum_y = 0;\n  let sum_xy = 0;\n  let sum_xx = 0;\n  let sum_yy = 0;\n\n  for (let j = 0; j < y.length; j++) {\n      sum_x += x[j];\n      sum_y += y[j];\n      sum_xy += (x[j]*y[j]);\n      sum_xx += (x[j]*x[j]);\n      sum_yy += (y[j]*y[j]);\n  } \n\n  reg.x = x;\n  reg.y = y;\n  reg.slope = (n * sum_xy - sum_x * sum_y) / (n*sum_xx - sum_x * sum_x);\n  reg.intercept = (sum_y - reg.slope * sum_x)/n;\n  reg.fitY = x.map(e => (reg.slope * e + reg.intercept));\n  reg.r2 = Math.pow((n*sum_xy - sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);\n  \n  let error = y.map((n, i, a) => y[i] - reg.fitY[i]); \n  // estiamted variance of error\n  let sigSq = error.map(n => Math.pow(n, 2)).reduce(\n    (a, b) => a + b, 0) * (1 / reg.fitY.length);\n  reg.logLik = y.map((e, i) => Math.log(\n    normalDensity(e, reg.fitY[i], sigSq)\n    )\n    ).reduce(\n      (a, b) => a + b\n      ); \n\n  let rss = reg.fitY\n      .map((e,i) => e-reg.y[i])\n      .map(e => Math.pow(e,2))\n      .reduce((a,b) => a+b)\n  reg.rms = rss / (reg.y.length - 2);\n\n  return reg;\n}\n\n// Function for likelihood in linearRegression() function\n export function normalDensity(y: number, mu: number, sigSq: number) {\n  let exp = -0.5 * ((y - mu) ** 2) / sigSq; // exponent\n  let norm = 1 / (Math.sqrt(2 * Math.PI * sigSq)); // normalising factor\n  return norm * (Math.E ** exp);\n}\n\n// Information criteria functions below \nexport function AICc(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + ((6 * f * n) / (n - (3 * f) - 1))); \n}\n\nexport function AIC(regs: Regression[]): number {\n  var f = regs.length;\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + (6 * f)); \n}\n\nexport function BIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (3 * f * Math.log(n) - (2 * totLogLik)); \n}","import { regression, LocalClockModel } from \"./core\"\nimport { Tree, readNewick } from \"phylojs\";\n\n/**\n * Creates a web worker for clock search in background thread\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number} minCladeSize - Minimum group size for search\n * @param {number} maxClocks - Max clocks to search for. Searches for 1..maxClocks\n * @param {number[]} dates - Tip dates\n * @param {\"aic\" | \"aicc\" | \"bic\"} icMetric - Information criterion used to determine best config. BIC reccommened.\n * @returns {Promise} - A Promise that resolves with the worker's response data.\n */\nexport function createClockSearchWorker(\n  nwk: string, \n  minCladeSize: number,\n  maxClocks: number,\n  dates: number[], \n  icMetric: \"aic\" | \"aicc\" | \"bic\"\n  ): Promise<LocalClockModel> {\n  return new Promise(function (resolve, reject) {\n    const worker = new Worker(new URL(\"./clockSearchWorker.ts\", import.meta.url));\n    worker.postMessage({\n      nwk: nwk, \n      minCladeSize: minCladeSize,\n      maxClocks: maxClocks,\n      dates: dates, \n      icMetric: icMetric\n    });\n    worker.onmessage = (e) => {\n      resolve(e.data);\n    };\n    worker.onerror = reject;\n  });\n}\n\n// Clock search function. Conver to a generator later\n// icMetric is the information criterion used to find 'best' state. TODO: Need to read these as part of input: aic | aicc | bic\nexport const clockSearch = (\n    nwk: string,\n    minCladeSize: number,\n    maxClocks: number,\n    dates: Array<number>,\n    icMetric: \"aic\" | \"aicc\" | \"bic\"\n    ) => {\n  \n    var tree = readNewick(nwk)\n    \n    var allGroups: string[][][] = [];\n    for (let i = 1; i <= maxClocks; i++) {\n        allGroups = allGroups.concat(\n            getGroups(\n                tree,\n                minCladeSize,\n                i\n            ))\n    }\n\n    var tipNames = tree.getTipLabels();\n    var tipHeights = tree.getRTTDist();\n\n    // error for too many clocks\n    const error = Error(`Too may clocks for minimum clade size. Spurious results await`)\n    if (maxClocks > Math.floor(tipNames.length / minCladeSize) ){\n      console.error(error.message)\n    } \n\n\n    var groupsNumbered = allGroups.map(\n      (e:string[][]) => makeGroups(\n        tipNames, \n        e)\n    )\n    \n    var fits: LocalClockModel[] = [];\n    for (let i = 0; i < allGroups.length; i++){\n        fits.push(\n            regression(\n                tipHeights,\n                dates,//TODO: is dates in the right order? - keep in state?\n                groupsNumbered[i],\n                tipNames\n                )\n            );     \n    }\n\n    // Now find the most supported configuration. Want baseIC iff one group\n    var ic: number[] = fits.map(\n        e => e.localClock ? e.localIC[icMetric] : e.baseIC[icMetric]\n        );\n\n    var minIC = Math.min(...ic); \n\n    var indexBest = ic.indexOf(minIC);\n    return fits[indexBest];\n  }\n  \n  export function getGroups (tree: Tree, minGroupSize: number, numClocks: number): string[][][] {\n    var tipNodes = tree.getNodeList().map(\n      e => tree.getSubtree(e).getTipLabels()\n    )\n\n    // TODO: Throw error if numClocks > nTips / minGroupSize. Needs Parse Int\n    var tips = tipNodes.sort(\n      (a: string[], b: string[]) => {return b.length - a.length}\n    ).filter(\n      (e: string[]) => e.length >= minGroupSize\n    );\n  \n    // [1,...,tips.length] as array for combn()\n    let nums = [...Array(tips.length)].map((e, i) => i).slice(1);\n\n    var combinations: number[][] = combn(nums, (numClocks - 1));\n    \n    // return 0th clade for background rate, sort, and find unique\n    combinations.map(\n        (e: number[]) => e.unshift(0)\n        )\n\n    // Convert number combinations to corresponding groups of tips\n    var allGroups: string[][][] = [];\n    var tmp: string[][] = []\n    for (let i = 0; i < combinations.length; i++){\n      tmp = combinations[i].map(\n        (e: number) => tips[e]\n      )\n      allGroups.push(tmp);\n    }\n\n    allGroups = allGroups.map(e => unNest(e))\n    // allGroups = allGroups.map(e => e.sort()) // sorting for testing\n    \n    // Filter out all groups with fewer than ${minCladeSize} tips\n    var finalGroups = allGroups.filter(\n      (e0: string[][]) => !(\n        e0.some(\n          (e1: string[]) => e1.length < minGroupSize\n        )\n      ) \n    );\n\n    // de-duplicating\n    finalGroups = finalGroups.map(\n      e => JSON.stringify(e)\n    ).filter(\n      (v,i,a)=>a.indexOf(v)===i\n    ).map(\n      e => JSON.parse(e)\n    )\n\n    return finalGroups;\n\n  }\n\n// Make groups into a 1D array of numbers coresponding to tips. TODO: test\nexport function makeGroups(tips: string[], nestedGrp: string[][]): string[] {\n let grp: string[] = []\n\n for (let i=0; i<tips.length; i++){\n  for (let j=nestedGrp.length-1; j>=0; j--){\n\n    if (nestedGrp[j].includes(tips[i])){\n      grp.push(j.toString())\n      break\n    } \n  \n  }\n }\n\n return grp;\n}\n\n  \n  // Un-nests group membership\n  export function unNest(arr: string[][]): string[][] {\n    var unNested: string[][] = [];\n\n    unNested[arr.length-1] = arr[arr.length-1];\n    for (let i = arr.length-2; i>=0; i--){\n      unNested[i] = arr[i].filter(\n        (e: string) => !arr.slice(i+1).flat().includes(e)\n      )\n    }\n    return unNested.sort();\n  }\n  \n  // generating combinations of groups\n   export function combn(arr: any[], k: number): number[][] {\n    // Store all possible combinations in a result array\n    const result: number[][] = [];\n  \n    // Generate all combinations using a recursive helper function\n    function generateCombinations(currentIndex: number, currentCombination: any[]): void {\n      // If the current combination has the desired length, add it to the result array\n      if (currentCombination.length === k) {\n        result.push(currentCombination);\n        return;\n      }\n  \n      // Generate all possible combinations starting from the next element in the array\n      for (let i = currentIndex; i < arr.length; i++) {\n        generateCombinations(i + 1, currentCombination.concat(arr[i]));\n      }\n    }\n  \n    // Start the recursive process with the first element in the array\n    generateCombinations(0, []);\n  \n    // Return the result array\n    return result;\n  }\n  ","import { clockSearch } from \"./clockSearch\";\n\n// this runs on the webworker, created with webpack 5 syntax new\n// Worker('./worker.ts'). in jest tests, this module is not used, instead the\n// workerMessageHandler is directly addressed\nself.onmessage = ( /* eslint-disable-line no-restricted-globals */\n  { \n    data: { \n      nwk,\n      minCladeSize,\n      maxClocks,\n      dates,\n      icMetric  \n    } \n  }\n) => { /* eslint-disable-line no-restricted-globals */\n \n  let bestGrpConfig = clockSearch(\n      nwk,\n      minCladeSize,\n      maxClocks,\n      dates,\n      icMetric\n    )\n  \n  self.postMessage(bestGrpConfig); /* eslint-disable-line no-restricted-globals */\n}; ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [495], function() { return __webpack_require__(43402); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"402\":\"cae6c50a\",\"495\":\"32464121\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t402: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkclockor2\"] = self[\"webpackChunkclockor2\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(495).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["_arrayLikeToArray","arr","len","length","i","arr2","Array","_toConsumableArray","isArray","iter","Symbol","iterator","from","o","minLen","n","Object","prototype","toString","call","slice","constructor","name","test","TypeError","require","regression","tipHeights","dates","groupings","tipNames","dataPoints","groupData","lcm","baseClock","linearRegression","baseIC","aic","AIC","aicc","AICc","bic","BIC","localClock","map","e","localIC","groupNames","points","unique","filter","v","a","indexOf","sort","numericGroupings","group","tmp","x","y","tip","push","unshift","reg","sum_x","sum_y","sum_xy","sum_xx","sum_yy","j","slope","intercept","fitY","r2","Math","pow","sqrt","sigSq","reduce","b","logLik","log","mu","exp","PI","E","normalDensity","rss","rms","regs","f","totLogLik","getGroups","tree","minGroupSize","numClocks","tips","getNodeList","getSubtree","getTipLabels","nums","combinations","k","result","generateCombinations","currentIndex","currentCombination","concat","combn","allGroups","unNested","flat","includes","unNest","finalGroups","e0","some","e1","JSON","stringify","parse","self","onmessage","data","bestGrpConfig","nwk","minCladeSize","maxClocks","icMetric","readNewick","getRTTDist","error","Error","floor","console","message","groupsNumbered","nestedGrp","grp","makeGroups","fits","ic","minIC","min","clockSearch","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","keys","every","key","splice","r","chunkId","Promise","all","promises","u","miniCssF","obj","prop","hasOwnProperty","p","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}