{"version":3,"file":"static/js/245.e1fe04c7.chunk.js","mappings":"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","sources":["features/engine/core.ts","features/engine/utils.ts","features/engine/bestFittingRoot.ts","features/engine/bfrWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["// eslint-disable-next-line \n\n\nimport {phylotree, rootToTip} from \"phylotree\" // for clock search TODO: Add best fitting root soon!\n\n// import { group } from \"console\";\n// import { maxHeaderSize } from \"http\";\n\nconst chroma = require(\"chroma-js\") // TODO: Learn about why this works instead of import\n\n// class to contain local clock model, incl. data points and information criteria\nexport interface LocalClockModel {\n  baseClock: Regression;\n  localClock: Regression[];\n  baseIC: InfoMetric;\n  localIC: InfoMetric;\n  groupNames: string[];\n}\n// interface for info metric data\ninterface InfoMetric {\n  aic: number;\n  aicc: number;\n  bic: number;\n}\n\n// function to make plottable points\n// method for plotly plotting\nexport function plotify(lcm: LocalClockModel | null): Plotly.Data[] | null {\n  const plot = [] as Plotly.Data[];\n  if (lcm != null) {\n    // generate colour scale. Use viridis-ish default\n    const cols = lcm.localClock\n      ?\n      chroma.scale(['#fafa6e', '#2A4858']).mode('lch').colors(lcm.localClock.length)\n      :\n      \"DarkSlateGrey\";\n\n    // Pushing plotly object for base lock\n    var point = {\n      x: lcm.baseClock.x,\n      y: lcm.baseClock.y,\n      text: lcm.baseClock.tip,\n      marker: {color: '#000000', size: 5},\n      mode: \"markers\",\n      name: \"Global\",\n      legendgroup: \"Global\",\n      showlegend: false\n    }\n    plot.push(point);\n\n    var line = {\n      x: lcm.baseClock.x,\n      y: lcm.baseClock.fitY,\n      name: \"Global\",\n      marker : {color: '#000000'},\n      mode: \"lines\",\n      text: lcm.localClock\n      ? \n        `Global<br>R2: ${lcm.baseClock.r2.toFixed(2)}` \n      : \n        `R2: ${lcm.baseClock.r2.toFixed(2)}`,\n\n      legendgroup: \"Global\"\n    }\n    plot.push(line);\n\n    // pushing plotly object for each local clock\n    if (lcm.localClock){\n      for (let i = 0; i < lcm.localClock.length; i++) {\n        var point1 = {\n          x: lcm.localClock[i].x,\n          y: lcm.localClock[i].y,\n          text: lcm.localClock[i].tip,\n          marker: {color: cols[i], line: {width: 1, color: 'DarkSlateGrey'}},\n          mode: \"markers\",\n          legendgroup: lcm.groupNames[i+1].length > 1 ? lcm.groupNames[i+1] : `Local Clock ${i+1}`,\n          name: lcm.groupNames[i+1],\n          showlegend: false\n        }\n        plot.push(point1);\n\n        var line1 = {\n          x: lcm.localClock[i].x,\n          y: lcm.localClock[i].fitY,\n          text: `${lcm.groupNames[i+1] ?? `Local Clock ${i+1}`}<br>R2: ${lcm.localClock[i].r2.toFixed(2)}`,\n          marker : {color: cols[i], line: {width: 1, color: 'DarkSlateGrey'}},\n          mode: \"lines\",\n          legendgroup: lcm.groupNames[i+1].length > 1 ? lcm.groupNames[i+1] : `Local Clock ${i+1}`,\n          name: lcm.groupNames[i+1]\n        }\n        plot.push(line1);\n      }\n    }\n      return plot;\n  } else {\n    return null;\n  }\n  }\n\n\n\ninterface Style {\n  color: string;\n}\n\nexport interface Regression {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  fitY: Array<number>;\n  slope: number;\n  intercept: number;\n  sigSq: number;\n  r2: number;\n  logLik: number;\n}\n\n// Groups of points pertaining to one local clock\n// To be apended in array for linearRegression()\ninterface DataGroup {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  name: string;\n}\n\n//////////////////////////////////////////////////////\n// BELOW: CORE ENGINE FUNCTIONS SUCH AS SOMETHING() //\n// INCORPORATE FUNCTIONS DEFINED BELOW              //\n//////////////////////////////////////////////////////\n\n// Core function. Functionality for groups to be added\nexport const regression = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings: Array<string>,\n  tipNames: Array<string>) => {\n\n  var dataPoints = groupData(tipHeights, dates, groupings, tipNames);\n\n  var lcm = {} as LocalClockModel;\n  \n  lcm.baseClock = linearRegression(dataPoints[0]);\n  lcm.baseIC = {} as InfoMetric;\n  lcm.baseIC.aic = AIC([lcm.baseClock]);\n  lcm.baseIC.aicc = AICc([lcm.baseClock]);\n  lcm.baseIC.bic = BIC([lcm.baseClock]);\n\n  if (dataPoints.length > 1) {\n    lcm.localClock = dataPoints.slice(1).map(e => linearRegression(e));\n    lcm.localIC = {} as InfoMetric;\n    lcm.localIC.aic = AIC(lcm.localClock);\n    lcm.localIC.aicc = AICc(lcm.localClock);\n    lcm.localIC.bic = BIC(lcm.localClock);\n  }\n\n  lcm.groupNames = dataPoints.map(e => e.name)\n  \n  return lcm;\n}\n\n// Clock search function. Conver to a generator later\n// icMetric is the information criterion used to find 'best' state. TODO: Need to read these as part of input: aic | aicc | bic\n// export const clockSearch = (tree: any,\n//   minCladeSize: number,\n//   numClocks: number,\n//   tipHeights: Array<number>,\n//   dates: Array<number>,\n//   tipNames: Array<string>,\n//   icMetric: string) => {\n\n//   // generate all possibilities for groupings\n//   let allGroups = getGroups(tree, minCladeSize, numClocks);\n//   let allGroupsNumber = allGroups.map((e: string[][]) => groupToNum(e, tips));\n\n//   // Loop through group possibilities and append to fits\n//   let fits: LocalClockModel[] = [];\n//   for (let i = 0; i < allGroups.length; i++){\n//       fits.push(regression(tipHeights, dates, allGroups[i], tipNames)); \n//   }\n\n//   // Now find the most supported configuration\n//   // Getting array of IC values based on selected IC TODO: Add capability for multiple ICs\n//   const ic = fits.map(e => e[icMetric as keyof LocalClockModel]) // TODO: Test here!\n\n//   var icMaxStep = ic.indexOf(Math.max(...(ic as number[]))); // TODO: This might throw an error if we never see output\n\n//   return fits[icMaxStep];\n// }\n\n////////////////////////////////////////////////////////\n// BELOW: FUNCTIONS USED INSIDE CORE ENGINE FUNCTIONS //\n////////////////////////////////////////////////////////\n\n// function groups points for local clock regresion\n// 0th element of array is always points for single clock\nconst groupData = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings:  Array<string>,\n  tipNames: Array<string>\n  ): DataGroup[] => { \n\n  const points: DataGroup[] = [];\n\n  let unique = groupings.filter((v, i, a) => a.indexOf(v) === i).sort();\n  let numericGroupings =  groupings.map(group => unique.indexOf(group))\n\n  for (let i = 0; i < unique.length; i++) {\n    var tmp: DataGroup = {x: [], y: [], tip: [], name: unique[i]};\n    points.push(tmp);\n  }\n\n  for (let i = 0; i < groupings.length; i++) {\n    points[numericGroupings[i]].x.push(\n      dates[i]\n    )\n    points[numericGroupings[i]].y.push(\n      tipHeights[i]\n    )\n    points[numericGroupings[i]].tip.push(\n      tipNames[i]\n    )\n  }\n  // if  num groups > 1, append the baseline fit (all points in one group)\n  // In the case num groups = 1, this is automatically appended\n  if (unique.length > 1) {\n    points.unshift({\n      x: dates,\n      y: tipHeights,\n      tip: tipNames,\n      name: \"Global\"\n    })}\n\n  return points;\n}\n\n// regression function \nexport function linearRegression(points: DataGroup) {\n  let reg = {} as Regression;\n\n  // carrying tips over first\n  reg.tip = points.tip;\n\n  let x = points.x;\n  let y = points.y;\n\n  let sum_x = 0;\n  let n = y.length;\n  let sum_y = 0;\n  let sum_xy = 0;\n  let sum_xx = 0;\n  let sum_yy = 0;\n\n  for (let j = 0; j < y.length; j++) {\n      sum_x += x[j];\n      sum_y += y[j];\n      sum_xy += (x[j]*y[j]);\n      sum_xx += (x[j]*x[j]);\n      sum_yy += (y[j]*y[j]);\n  } \n\n  // Include these later after agreeing on how to pass to front end\n  reg.x = x;\n  reg.y = y;\n  reg.slope = (n * sum_xy - sum_x * sum_y) / (n*sum_xx - sum_x * sum_x);\n  reg.intercept = (sum_y - reg.slope * sum_x)/n;\n  reg.fitY = x.map(e => (reg.slope * e + reg.intercept));\n  reg.r2 = Math.pow((n*sum_xy - sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);\n  //calculate log likelihood\n  \n  let error = y.map((n, i, a) => y[i] - reg.fitY[i]); \n  // estiamted variance of error\n  let sigSq = error.map(n => Math.pow(n, 2)).reduce(\n    (a, b) => a + b, 0) * (1 / reg.fitY.length);\n  //reg.logLik = y.map((e, i) => Math.log(normalDensity(e, reg.fitY[i], sigSq))).reduce((a, b) => a + b); \n  reg.logLik = y.map((e, i) => Math.log(\n    normalDensity(e, reg.fitY[i], sigSq)\n    )\n    ).reduce(\n      (a, b) => a + b\n      ); \n\n  return reg;\n}\n\n// Function for likelihood in linearRegression() function\n export function normalDensity(y: number, mu: number, sigSq: number) {\n  let exp = -0.5 * ((y - mu) ** 2) / sigSq; // exponent\n  let norm = 1 / (Math.sqrt(2 * Math.PI * sigSq)); // normalising factor\n  return norm * (Math.E ** exp);\n}\n\n// Information criteria functions below \nexport function AICc(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + ((6 * f * n) / (n - (3 * f) - 1))); \n}\n\nexport function AIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + (6 * f)); \n}\n\nexport function BIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (3 * f * Math.log(n) - (2 * totLogLik)); \n}\n\nexport function getGroups (tree: any, minCladeSize: number, numClocks: number): string[][][] {\n  // Sets of tips descending from each node\n  var tips: any = [];\n  // list tips descending from each node\n  tree.nodes.each((node: any) => tips.push(node.leaves())); \n  // map to just tip names\n  var tips = tips.map((e0: any) => e0.map((e1: any) => e1.data.name));\n  // De-duplicate tips (artefact from d3 hierarchy)\n  var uniqueTips = tips.map(\n    (e: string[]) => JSON.stringify(e)\n    ).filter(\n      (e: string[], i: number, a: string[][]) => {return a.indexOf(e) === i}\n      ).map(\n       (e: string) => JSON.parse(e)\n        )\n  // Sort clades based on size. Largest (all tips) goes first\n  var sortedUniqueTips = uniqueTips.sort((a: string[], b: string[]) => {return b.length - a.length});\n\n  // Filter out all clades with fewer than ${minCladeSize} tips\n  var finalClades = sortedUniqueTips.filter((e: string[]) => e.length >= minCladeSize);\n\n  // array from 1:(finalClades.length) possible clades to draw combinations\n  var grpNums = Array.from(Array(finalClades.length).keys());\n  // +1 to account for 0th base clock\n  //var grpNums = grpNums.map((e: number, i: number ) => i+1); \n  \n  // remove 0th group - that being all tips. Add back in later\n  grpNums.shift()\n  // get all combinations of groups to make up ${numClocks} local clocks\n  let comb = combn(grpNums, (numClocks - 1))\n  // add 0th clade for background rate\n  comb.map((e: number[]) => e.unshift(0)); \n\n  // Convert number combinations to corresponding groups of tips\n  let allGroups: string[][][] = [];\n  for (let i = 0; i < comb.length; i++){\n    allGroups.push(\n      comb[i].map(\n        (e: number) => finalClades[e]\n      )\n    );\n  }\n\n  //return groups after converting to non-intersecting groups;\n  return allGroups.map(e => getUnique(e));\n\n  // TODO: Size-filtering and defend against requesting too many clocks\n}\n\n// function takes string[][] and maps each to unique values assuming each string[] is nested as for allGroups\nexport function getUnique(x: string[][]): string[][] {\n  return x.map((e0: string[], i) => e0.filter(\n      (e1: string) => {\n        if(i+1 < x.length) { \n          return !x[i+1].includes(e1); \n        } else {\n          return true;\n        }\n      })\n  );\n}\n\n// A function that takes a list of tips and returns group number based on an element of allGroups\nfunction groupToNum(arr: string[][], tips: string[]): number[] {\n    let groupings: number[] = []; \n\n    for (let i = 0; i < tips.length; i++){\n      var tmp = [];\n      \n      for (let j = 0; j < arr.length; j++) {\n        if (arr[j].indexOf(tips[i]) > -1) {\n          groupings[i] = j;\n        } \n      }\n    }\n  return groupings;\n} // TODO: Include a test here to check that output is all integers and that ordering of tips matches input\n\n\n// generating combinations of groups\n export function combn(arr: any[], k: number): number[][] {\n  // Store all possible combinations in a result array\n  const result: number[][] = [];\n\n  // Generate all combinations using a recursive helper function\n  function generateCombinations(currentIndex: number, currentCombination: any[]): void {\n    // If the current combination has the desired length, add it to the result array\n    if (currentCombination.length === k) {\n      result.push(currentCombination);\n      return;\n    }\n\n    // Generate all possible combinations starting from the next element in the array\n    for (let i = currentIndex; i < arr.length; i++) {\n      generateCombinations(i + 1, currentCombination.concat(arr[i]));\n    }\n  }\n\n  // Start the recursive process with the first element in the array\n  generateCombinations(0, []);\n\n  // Return the result array\n  return result;\n}\n","\nexport const decimal_date = (date: Date) => {\n    var full_year = date.getFullYear();\n    var year_start = new Date(full_year, 0, 1).getTime(),\n        year_start_p1 = new Date(full_year + 1, 0, 1).getTime();\n\n    const decimal_date_value =\n        full_year + (date.getTime() - year_start) / (year_start_p1 - year_start);\n\n    return decimal_date_value;\n  };\n\nexport const createGroups = (decimal_dates:number[], tipHeights: number[], tipNames: number[], groupings:number[]) => {\n    /**\n     * Splits arrays into groups \n     * This method returns a array of group objects\n     */\n    let unique = groupings.filter((v, i, a) => a.indexOf(v) === i);\n    let groups = unique.map(() => {return {tipHeights:[] as number[], decimal_dates:[] as number[], tipNames: [] as number[]}})\n\n    for (let index = 0; index < groupings.length; index++) {\n      groups[groupings[index]].decimal_dates.push(\n        decimal_dates[index]\n      )\n      groups[groupings[index]].tipHeights.push(\n        tipHeights[index]\n      )\n      groups[groupings[index]].tipNames.push(\n        tipNames[index]\n      )\n    }\n    return groups\n  }\n\n  interface TreeNode {\n    data: {\n      name: string;\n      attribute?: number;\n    };\n    children?: TreeNode[];\n\n  }\n  function dfs(node: TreeNode, distanceFromRoot: number, leafDistances: Map<string, number>): Map<string, number> {\n    if (!node.children || node.children.length === 0) {\n      leafDistances.set(node.data.name, distanceFromRoot);\n    } else {\n      node.children.forEach((child) => {\n        const distance = Number(child.data.attribute) || 0;\n        dfs(child, distanceFromRoot + distance, leafDistances);\n      });\n    }\n    return leafDistances;\n  }\n  \n  function computeDistances(tree: any): Map<string, number> {\n    const leafDistances = new Map<string, number>();\n    return dfs(tree.nodes, 0, leafDistances);\n  }\n\n  export const getTipHeights = (tree: any): number[] => {\n    let distances = computeDistances(tree)\n    return tree.getTips().map((tip: any) => distances.get(tip.data.name)) // reorder the nodes \n  }\n\n  export const getTipNames = (tree: any): string[] => {\n    return tree.getTips().map((tip: any) => tip.data.name);\n  }\n","import { phylotree } from \"phylotree\";\nimport { linearRegression } from \"./core\";\nimport { getTipHeights, getTipNames } from \"./utils\";\nvar minimize = require(\"minimize-golden-section-1d\");\n\nexport interface localOptima {\n  r2: number;\n  alpha: number;\n  nodeIndx: number;\n}\n\n/**\n * Creates a web worker for parallel processing and sets up message passing with the worker.\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @param {number[]} nodes - An array of node indices to be processed by the worker.\n * @returns {Promise} - A Promise that resolves with the worker's response data.\n */\nfunction createWorker(nwk: string, dates: number[], nodes: number[], tipData: any) {\n  return new Promise(function (resolve, reject) {\n    const worker = new Worker(new URL(\"./bfrWorker.ts\", import.meta.url));\n    worker.postMessage({\n      nwk: nwk,\n      dates: dates,\n      nodeNums: nodes,\n      tipData: tipData\n    });\n    worker.onmessage = (e) => {\n      resolve(e.data);\n    };\n    worker.onerror = (e) => reject(e.error);\n  });\n}\n\n/**\n * Finds the best root for a phylogenetic tree by searching through all possible roots in parallel.\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @returns {Promise<string>} - A Promise that resolves with the Newick string of the best rooted tree.\n */\nexport async function globalRootParallel(nwk: string, dates: number[], tipData: any) {\n  var t0 = new Date().getTime();\n\n  const tree = new phylotree(nwk);\n  var nodes = tree.nodes.descendants();\n  var nodeNums = nodes.map((e: any, i: number) => i).slice(1);\n\n  var nodeNumsChunked = spliceIntoChunks(\n    nodeNums,\n    (nodeNums.length - 1) / window.navigator.hardwareConcurrency\n  );\n\n  var promises = nodeNumsChunked.map((e: number[]) =>\n    createWorker(nwk, dates, e, tipData)\n  );\n\n  var prime = (await Promise.all(promises));\n\n  prime.unshift({\n    ...localRoot(tree, dates),\n    nodeIndx: 0,\n  });\n\n  var r2 = prime.map((e: any) => e.r2);\n\n  var bestR2 = Math.max(...r2);\n\n  var bestIndx = r2.indexOf(bestR2);\n  var best: any = prime[bestIndx];\n\n  let bestTree = new phylotree(nwk);\n\n  rerootAndScale(bestTree, best);\n\n  var t1 = new Date().getTime()\n\n  console.log(\"Time Taken for BFR(s) \" + Math.abs(t1-t0) / 1000)\n  return bestTree.getNewick();\n}\n\n/**\n * Reroots at best node and rescales basal branch lengths.\n * \n * @param {any} bestTree - The best rooted phylotree instance.\n * @param {any} best - The best local optima information.\n */\nfunction rerootAndScale(bestTree: any, best: any) {\n\n  if (best.nodeIndx !== 0) {\n    bestTree.reroot(bestTree.nodes.descendants()[best.nodeIndx]);\n  }\n\n  bestTree.nodes.each((n: any) => {\n    if (typeof n.data.__mapped_bl == \"undefined\") {\n      n.data.__mapped_bl = \"0.0\";\n    }\n    if (n.data.__mapped_bl) {\n      n.data.attribute = n.data.__mapped_bl.toString();\n    } \n  });\n\n  let bl = [\n    bestTree.nodes.children[0].data.attribute,\n    bestTree.nodes.children[1].data.attribute\n  ].map (\n    e => parseFloat(e)\n  )\n  let len = bl.reduce((p,c) => p+c, 0)\n\n  bestTree.nodes.children[0].data.attribute = (best.alpha * len).toString();\n  bestTree.nodes.children[1].data.attribute = ((1 - best.alpha) * len).toString();\n\n  bestTree.setBranchLength((n: any) => {\n    return n.data.attribute;\n  });\n\n}\n\n/**\n * Finds the best local root for a given phylogenetic tree.\n *\n * @param {any} tree - A phylotree instance representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @returns {object} - An object containing the best alpha value and the corresponding R2 value.\n */\nexport function localRoot(tree: any, dates: number[]) {\n  var tipNames: string[] = getTipNames(tree);\n  var tipHeights: number[] = getTipHeights(tree);\n\n  var desc0: string[] = tree.nodes.children[0].leaves().map(\n    (e: any) => e.data.name\n  );\n\n  var indicator: number[] = [];\n  for (let i = 0; i < tipNames.length; i++) {\n    desc0.includes(tipNames[i]) ? indicator.push(1) : indicator.push(0);\n  }\n\n  let bl = [\n    tree.nodes.children[0].data.attribute,\n    tree.nodes.children[1].data.attribute\n  ].map(e => parseFloat(e))\n\n    let length = bl.reduce((a, b) => a+b, 0)\n\n  // Efficiency boost skipping opimisation for effectively 0-length branches\n  // (ie. < 10^-8)\n  // if (length <= 1e-8) {\n  //   return { \n  //     alpha: 0.5, \n  //     r2: linearRegression({ x: dates, y: tipHeights, tip: tipNames, name: 'NA' }).r2\n  //   }\n  // }\n\n  const univariateFunction = (x: number) => {\n    let tipHeightsNew = tipHeights.map(\n      (e, i) =>\n        indicator[i] * (e - bl[0] + (x * length)) + // changed indx\n        (1 - indicator[i]) * (e - bl[1] + ((1 - x) * length)) // changed indx\n    );\n\n    return -1 * linearRegression({ x: dates, y: tipHeightsNew, tip: tipNames, name: 'NA' }).r2;\n  };\n\n  let alpha = minimize(univariateFunction, { lowerBound: 0, upperBound: 1 });\n  return { alpha: alpha, r2: -1 * univariateFunction(alpha) };\n}\n\ninterface TipIndices {\n  [key: string]: number;\n}\n\n/**\n * Reorders an array of data based on the correspondence between the current and target tip names.\n *\n * @param {number[]} arr - The array of data to be reordered.\n * @param {string[]} currentTip - An array of the current tip names.\n * @param {string[]} targetTip - An array of the target tip names.\n * @returns {number[]} - The reordered array of data.\n */\nexport function reorderData(arr: number[], currentTip: string[], targetTip: string[]) {\n  const targetTipIndices: TipIndices = {};\n  for (let i = 0; i < targetTip.length; i++) {\n    targetTipIndices[targetTip[i]] = i;\n  }\n\n  const arrOrdered = currentTip.map((tip) => {\n    const index = targetTipIndices[tip];\n    return arr[index];\n  });\n\n  return arrOrdered;\n}\n\n/**\n * Splits an array into chunks of the specified size.\n *\n * @param {number[]} arr - The array to be split into chunks.\n * @param {number} chunkSize - The size of each chunk.\n * @returns {number[][]} - An array of chunks.\n */\nfunction spliceIntoChunks(arr: number[], chunkSize: number) {\n  const res = [];\n  while (arr.length > 0) {\n    const chunk = arr.splice(0, chunkSize);\n    res.push(chunk);\n  }\n  return res;\n}","import { phylotree } from \"phylotree\";\nimport { localRoot, localOptima, reorderData } from \"./bestFittingRoot\";\nimport { getTipNames } from \"./utils\";\n\n\n\n// this runs on the webworker, created with webpack 5 syntax new\n// Worker('./worker.ts'). in jest tests, this module is not used, instead the\n// workerMessageHandler is directly addressed\nself.onmessage = ({ data: { nwk, dates, nodeNums, tipData } }) => { /* eslint-disable-line no-restricted-globals */\n  var tree = new phylotree(nwk)\n  var treePrime: any = {}\n  var datesPrime: number[] = []\n  var localOptimum: localOptima\n  var best: localOptima\n\n  // first node case\n  treePrime = new phylotree(nwk);\n  treePrime.reroot(treePrime.nodes.descendants()[nodeNums[0]]);\n  // set branch lengths\n  treePrime.nodes.each((n: any) => {\n    if (n.data.__mapped_bl){\n      n.data.attribute = n.data.__mapped_bl.toString();\n    }\n  })\n\n  // datesPrime = reorderData(\n  //   dates,\n  //   tree.getTips().map((e: any) => e.data.name),\n  //   treePrime.getTips().map((e: any) => e.data.name)\n  // )\n  datesPrime = getTipNames(treePrime).map(\n    e => tipData[e].date\n  )\n\n  best = {\n    ...localRoot(\n      treePrime,\n      datesPrime\n    ),\n    nodeIndx: nodeNums[0]\n    }\n\n  // compare to rest of nodes\n  for (let i=1; i<nodeNums.length; i++) {\n    treePrime = new phylotree(nwk);\n    treePrime.reroot(treePrime.nodes.descendants()[nodeNums[i]]);\n    // set branch lengths\n    treePrime.nodes.each((n: any) => {\n      if (n.data.__mapped_bl){\n        n.data.attribute = n.data.__mapped_bl.toString();\n      }\n    })\n\n    // datesPrime = reorderData(\n    //   dates,\n    //   tree.getTips().map((e: any) => e.data.name),\n    //   treePrime.getTips().map((e: any) => e.data.name)\n    // )\n    let datesPrime = getTipNames(treePrime).map(\n      e => tipData[e].date\n    )\n\n    localOptimum = {\n      ...localRoot(\n        treePrime,\n        datesPrime\n      ),\n      nodeIndx: nodeNums[i]\n    }\n\n    if (localOptimum.r2 - best.r2 > 1e-08) {\n      best = localOptimum;\n    }\n  }\n\n  self.postMessage(best); /* eslint-disable-line no-restricted-globals */\n}; ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [805,492], function() { return __webpack_require__(74245); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"245\":\"e1fe04c7\",\"492\":\"c5f12f55\",\"805\":\"d86e3fb0\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t245: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkclockor2\"] = self[\"webpackChunkclockor2\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([\n\t\t__webpack_require__.e(805),\n\t\t__webpack_require__.e(492)\n\t]).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["require","linearRegression","points","reg","tip","x","y","sum_x","n","length","sum_y","sum_xy","sum_xx","sum_yy","j","slope","intercept","fitY","map","e","r2","Math","pow","sqrt","sigSq","i","a","reduce","b","logLik","log","mu","exp","PI","E","normalDensity","dfs","node","distanceFromRoot","leafDistances","children","forEach","child","distance","Number","data","attribute","set","name","computeDistances","tree","Map","nodes","getTipNames","getTips","minimize","localRoot","dates","tipNames","tipHeights","distances","get","getTipHeights","desc0","leaves","indicator","includes","push","bl","parseFloat","univariateFunction","tipHeightsNew","alpha","lowerBound","upperBound","self","onmessage","datesPrime","localOptimum","best","nwk","nodeNums","tipData","treePrime","phylotree","reroot","descendants","each","__mapped_bl","toString","date","nodeIndx","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","every","key","splice","r","d","definition","o","defineProperty","enumerable","f","chunkId","Promise","all","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","value","nmd","paths","p","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}