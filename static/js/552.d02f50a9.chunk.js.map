{"version":3,"file":"static/js/552.d02f50a9.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","features/engine/core.ts","features/engine/bestFittingRoot.ts","features/engine/bfrWorker.ts","../node_modules/minimize-golden-section-1d/index.js","../node_modules/minimize-golden-section-1d/src/bracket-minimum.js","../node_modules/minimize-golden-section-1d/src/golden-section-minimize.js","../node_modules/phylojs/lib/index.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}","import { date_decimal } from \"./utils\";\nconst chroma = require(\"chroma-js\") // TODO: Learn about why this works instead of import\n\n// class to contain local clock model, incl. data points and information criteria\nexport interface LocalClockModel {\n  baseClock: Regression;\n  localClock: Regression[];\n  baseIC: InfoMetric;\n  localIC: InfoMetric;\n  groupNames: string[];\n}\n// interface for info metric data\ninterface InfoMetric {\n  aic: number;\n  aicc: number;\n  bic: number;\n}\n\n// function to make plottable points\n// method for plotly plotting\nexport function plotify(lcm: LocalClockModel | null): any[] | null {\n  const plot = [] as any[];\n  if (lcm != null) {\n    // generate colour scale. Use viridis-ish default\n    const cols = lcm.localClock !== undefined\n      ?\n      chroma.scale(['#fafa6e', '#2A4858']).mode('lch').colors(lcm.localClock.length)\n      :\n      \"DarkSlateGrey\";\n\n    // Pushing plotly object for base lock\n    var point = {\n      x: lcm.baseClock.x.map(e => date_decimal(e)),\n      y: lcm.baseClock.y,\n      text: lcm.baseClock.tip,\n      marker: {color: '#000000', size: 5},\n      mode: \"markers\",\n      name: \"Global\",\n      legendgroup: \"Global\",\n      showlegend: false,\n      type: \"scattergl\"\n    }\n    plot.push(point);\n\n    var line = {\n      x: lcm.baseClock.x.map(e => date_decimal(e)),\n      y: lcm.baseClock.fitY,\n      name: \"Global\",\n      marker : {color: '#000000'},\n      mode: \"lines\",\n      text: lcm.localClock\n      ? \n        `Global<br>R2: ${lcm.baseClock.r2.toFixed(2)}` \n      : \n        `R2: ${lcm.baseClock.r2.toFixed(2)}`,\n\n      legendgroup: \"Global\",\n      type: \"scattergl\"\n    }\n    plot.push(line);\n\n    // pushing plotly object for each local clock\n    if (lcm.localClock){\n      for (let i = 0; i < lcm.localClock.length; i++) {\n        var point1 = {\n          x: lcm.localClock[i].x.map(e => date_decimal(e)),\n          y: lcm.localClock[i].y,\n          text: lcm.localClock[i].tip,\n          marker: {color: cols[i], line: {width: 1, color: 'DarkSlateGrey'}},\n          mode: \"markers\",\n          legendgroup: lcm.groupNames[i+1].length > 1 ? lcm.groupNames[i+1] : `Local Clock ${i+1}`,\n          name: lcm.groupNames[i+1],\n          showlegend: false,\n          type: \"scattergl\"\n        }\n        plot.push(point1);\n\n        var line1 = {\n          x: lcm.localClock[i].x.map(e => date_decimal(e)),\n          y: lcm.localClock[i].fitY,\n          text: `${lcm.groupNames[i+1] ?? `Local Clock ${i+1}`}<br>R2: ${lcm.localClock[i].r2.toFixed(2)}`,\n          marker : {color: cols[i], line: {width: 1, color: 'DarkSlateGrey'}},\n          mode: \"lines\",\n          legendgroup: lcm.groupNames[i+1].length > 1 ? lcm.groupNames[i+1] : `Local Clock ${i+1}`,\n          name: lcm.groupNames[i+1],\n          type: \"scattergl\"\n        }\n        plot.push(line1);\n      }\n    }\n      return plot;\n  } else {\n    return null;\n  }\n}\n\nexport interface Regression {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  fitY: Array<number>;\n  slope: number;\n  intercept: number;\n  sigSq: number;\n  r2: number;\n  logLik: number;\n}\n\n// Groups of points pertaining to one local clock\n// To be apended in array for linearRegression()\ninterface DataGroup {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  name: string;\n}\n\n//////////////////////////////////////////////////////\n// BELOW: CORE ENGINE FUNCTIONS SUCH AS SOMETHING() //\n// INCORPORATE FUNCTIONS DEFINED BELOW              //\n//////////////////////////////////////////////////////\n\n// Core function. Functionality for groups to be added\nexport const regression = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings: Array<string>,\n  tipNames: Array<string>) => {\n\n  var dataPoints = groupData(tipHeights, dates, groupings, tipNames);\n\n  var lcm = {} as LocalClockModel;\n  \n  lcm.baseClock = linearRegression(dataPoints[0]);\n  lcm.baseIC = {} as InfoMetric;\n  lcm.baseIC.aic = AIC([lcm.baseClock]);\n  lcm.baseIC.aicc = AICc([lcm.baseClock]);\n  lcm.baseIC.bic = BIC([lcm.baseClock]);\n\n  if (dataPoints.length > 1) {\n    lcm.localClock = dataPoints.slice(1).map(e => linearRegression(e));\n    lcm.localIC = {} as InfoMetric;\n    lcm.localIC.aic = AIC(lcm.localClock);\n    lcm.localIC.aicc = AICc(lcm.localClock);\n    lcm.localIC.bic = BIC(lcm.localClock);\n  }\n\n  lcm.groupNames = dataPoints.map(e => e.name)\n  \n  return lcm;\n}\n\n////////////////////////////////////////////////////////\n// BELOW: FUNCTIONS USED INSIDE CORE ENGINE FUNCTIONS //\n////////////////////////////////////////////////////////\n\n// function groups points for local clock regresion\n// 0th element of array is always points for single clock\nexport const groupData = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings:  Array<string>,\n  tipNames: Array<string>\n  ): DataGroup[] => { \n\n  const points: DataGroup[] = [];\n\n  let unique = groupings.filter((v, i, a) => a.indexOf(v) === i).sort();\n  let numericGroupings =  groupings.map(group => unique.indexOf(group))\n\n  for (let i = 0; i < unique.length; i++) {\n    var tmp: DataGroup = {x: [], y: [], tip: [], name: unique[i]};\n    points.push(tmp);\n  }\n\n  for (let i = 0; i < groupings.length; i++) {\n    points[numericGroupings[i]].x.push(\n      dates[i]\n    )\n    points[numericGroupings[i]].y.push(\n      tipHeights[i]\n    )\n    points[numericGroupings[i]].tip.push(\n      tipNames[i]\n    )\n  }\n  // if  num groups > 1, append the baseline fit (all points in one group)\n  // In the case num groups = 1, this is automatically appended\n  if (unique.length > 1) {\n    points.unshift({\n      x: dates,\n      y: tipHeights,\n      tip: tipNames,\n      name: \"Global\"\n    })}\n\n  return points;\n}\n\n// regression function \nexport function linearRegression(points: DataGroup) {\n  let reg = {} as Regression;\n\n  reg.tip = points.tip;\n\n  let x = points.x;\n  let y = points.y;\n\n  let sum_x = 0;\n  let n = y.length;\n  let sum_y = 0;\n  let sum_xy = 0;\n  let sum_xx = 0;\n  let sum_yy = 0;\n\n  for (let j = 0; j < y.length; j++) {\n      sum_x += x[j];\n      sum_y += y[j];\n      sum_xy += (x[j]*y[j]);\n      sum_xx += (x[j]*x[j]);\n      sum_yy += (y[j]*y[j]);\n  } \n\n  reg.x = x;\n  reg.y = y;\n  reg.slope = (n * sum_xy - sum_x * sum_y) / (n*sum_xx - sum_x * sum_x);\n  reg.intercept = (sum_y - reg.slope * sum_x)/n;\n  reg.fitY = x.map(e => (reg.slope * e + reg.intercept));\n  reg.r2 = Math.pow((n*sum_xy - sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);\n  \n  let error = y.map((n, i, a) => y[i] - reg.fitY[i]); \n  // estiamted variance of error\n  let sigSq = error.map(n => Math.pow(n, 2)).reduce(\n    (a, b) => a + b, 0) * (1 / reg.fitY.length);\n  reg.logLik = y.map((e, i) => Math.log(\n    normalDensity(e, reg.fitY[i], sigSq)\n    )\n    ).reduce(\n      (a, b) => a + b\n      ); \n\n  return reg;\n}\n\n// Function for likelihood in linearRegression() function\n export function normalDensity(y: number, mu: number, sigSq: number) {\n  let exp = -0.5 * ((y - mu) ** 2) / sigSq; // exponent\n  let norm = 1 / (Math.sqrt(2 * Math.PI * sigSq)); // normalising factor\n  return norm * (Math.E ** exp);\n}\n\n// Information criteria functions below \nexport function AICc(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + ((6 * f * n) / (n - (3 * f) - 1))); \n}\n\nexport function AIC(regs: Regression[]): number {\n  var f = regs.length;\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + (6 * f)); \n}\n\nexport function BIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (3 * f * Math.log(n) - (2 * totLogLik)); \n}","import { linearRegression } from \"./core\";\nimport { Tree, readNewick, writeNewick } from \"phylojs\";\nvar minimize = require(\"minimize-golden-section-1d\");\n\nexport interface localOptima {\n  r2: number;\n  alpha: number;\n  nodeIndx: number;\n}\n\n/**\n * Creates a web worker for parallel processing and sets up message passing with the worker.\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @param {number[]} nodes - An array of node indices to be processed by the worker.\n * @returns {Promise} - A Promise that resolves with the worker's response data.\n */\nfunction createWorker(nwk: string, dates: number[], nodes: number[], tipData: any) {\n  return new Promise(function (resolve, reject) {\n    const worker = new Worker(new URL(\"./bfrWorker.ts\", import.meta.url));\n    worker.postMessage({\n      nwk: nwk,\n      dates: dates,\n      nodeNums: nodes,\n      tipData: tipData\n    });\n    worker.onmessage = (e) => {\n      resolve(e.data);\n    };\n    worker.onerror = (e) => reject(e.error);\n  });\n}\n\n/**\n * Finds the best root for a phylogenetic tree by searching through all possible roots in parallel.\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @returns {Promise<string>} - A Promise that resolves with the Newick string of the best rooted tree.\n */\nexport async function globalRootParallel(nwk: string, dates: number[], tipData: any) {\n\n  var t0 = new Date().getTime();\n\n  const tree: Tree = readNewick(nwk);\n  var nodes = tree.getNodeList();\n  var nodeNums = nodes.map((e: any, i: number) => i).slice(1);\n\n  var nodeNumsChunked = \n  nodeNums.length > window.navigator.hardwareConcurrency\n  ?\n    spliceIntoChunks(\n      nodeNums,\n      (nodeNums.length - 1) / window.navigator.hardwareConcurrency\n    )\n  :\n    [nodeNums];\n\n  var promises = nodeNumsChunked.map((e: number[]) =>\n    createWorker(nwk, dates, e, tipData)\n  );\n\n  var prime = (await Promise.all(promises));\n\n  prime.unshift({\n    ...localRoot(tree, tipData),\n    nodeIndx: 0,\n  });\n\n  var r2 = prime.map((e: any) => e.r2);\n\n  var bestR2 = Math.max(...r2);\n\n  var bestIndx = r2.indexOf(bestR2);\n  var best: any = prime[bestIndx];\n\n  let bestTree = readNewick(nwk);\n\n  rerootAndScale(bestTree, best);\n\n  var t1 = new Date().getTime()\n\n  console.log(\"Time Taken for BFR \" + Math.abs(t1-t0) / 1000 + \"s\")\n\n  return writeNewick(bestTree);\n}\n\n/**\n * Reroots at best node and rescales basal branch lengths.\n * \n * @param {Tree} bestTree - The best rooted phylotree instance.\n * @param {any} best - The best local optima information.\n * @returns {void} - Only manipulates bestTree\n */\nexport function rerootAndScale(bestTree: Tree, best: any): void {\n\n  if (best.nodeIndx !== 0) {\n    bestTree.reroot(bestTree.getNodeList()[best.nodeIndx]);\n  }\n\n  let bl = bestTree.root.children.map(\n    e => e.branchLength\n  ).map(\n    e => e === undefined ? 0 : e\n  )\n\n  let len = bl.reduce((a,b) => a+b, 0)\n\n  bestTree.root.children[0].branchLength = (best.alpha * len);\n  bestTree.root.children[1].branchLength = ((1 - best.alpha) * len);\n}\n\n\n/**\n * Finds the best local root for a given phylogenetic tree.\n *\n * @param {any} tree - A phylotree instance representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @returns {object} - An object containing the best alpha value and the corresponding R2 value.\n */\nexport function localRoot(tree: Tree, tipData: any) {\n  var tipNames: string[] = tree.getTipLabels();\n  var tipHeights: number[] = tree.getRTTDist(); \n  var dates = tipNames.map(e => tipData[e].date)\n\n  var desc0: string[] = tree.getSubtree(tree.root.children[0]).getTipLabels();\n\n  var indicator: number[] = [];\n  for (let i = 0; i < tipNames.length; i++) {\n    desc0.includes(tipNames[i]) ? indicator.push(1) : indicator.push(0);\n  }\n\n  let bl = tree.root.children.map(\n    e => e.branchLength\n  ).map(\n    e => e === undefined ? 0 : e\n  )\n  let len = bl.reduce((a, b) => a+b, 0)\n\n  // Skipping opimisation for effectively 0-length branches\n  if (len < Number.EPSILON) {\n    console.log('BFR Skipping node! <==> Sum Basal Branch Lengths < Number.EPSILON');\n    return { \n      alpha: 0.5, \n      r2: linearRegression({ x: dates, y: tipHeights, tip: tipNames, name: 'NA' }).r2\n    }\n  }\n\n  function univariateFunction(x: number) {\n    let tipHeightsNew = tipHeights.map((e, i) =>\n        indicator[i] * (e - bl[0] + (x * len)) +\n        (1 - indicator[i]) * (e - bl[1] + ((1 - x) * len))\n    );\n    return -1 * linearRegression({ x: dates, y: tipHeightsNew, tip: tipNames, name: 'NA' }).r2;\n  };\n\n  let alpha = minimize(univariateFunction, { lowerBound: 0, upperBound: 1, tolerance: Number.EPSILON, maxIterations: 1000});\n  \n  return { alpha: alpha, r2: -1 * univariateFunction(alpha) };\n}\n\n/**\n * Splits an array into chunks of the specified size.\n *\n * @param {number[]} arr - The array to be split into chunks.\n * @param {number} chunkSize - The size of each chunk.\n * @returns {number[][]} - An array of chunks.\n */\nexport function spliceIntoChunks(arr: number[], chunkSize: number) {\n  const res = [];\n  while (arr.length > 0) {\n    const chunk = arr.splice(0, chunkSize);\n    res.push(chunk);\n  }\n  return res;\n}","import { localRoot, localOptima } from \"./bestFittingRoot\";\nimport { readNewick, Tree } from \"phylojs\";\n\n\n// this runs on the webworker, created with webpack 5 syntax new\n// Worker('./worker.ts'). in jest tests, this module is not used, instead the\n// workerMessageHandler is directly addressed\nself.onmessage = ({ data: { nwk, nodeNums, tipData } }) => { /* eslint-disable-line no-restricted-globals */\n  var treePrime: Tree\n  var localOptimum: localOptima\n  var best: localOptima\n\n  // first node case\n  treePrime = readNewick(nwk);\n  treePrime.reroot(treePrime.getNodeList()[nodeNums[0]]);\n\n  best = {\n    ...localRoot(\n      treePrime,\n      tipData\n    ),\n    nodeIndx: nodeNums[0]\n  }\n\n  // compare to rest of nodes\n  for (let i=1; i<nodeNums.length; i++) {\n    \n    treePrime = readNewick(nwk);\n    treePrime.reroot(treePrime.getNodeList()[nodeNums[i]]);\n\n    localOptimum = {\n      ...localRoot(\n        treePrime,\n        tipData\n      ),\n      nodeIndx: nodeNums[i]\n    }\n\n    if (localOptimum.r2 - best.r2 > Number.EPSILON) {\n      best = localOptimum;\n    }\n  }\n\n  self.postMessage(best); /* eslint-disable-line no-restricted-globals */\n}; ","'use strict';\n\nvar goldenSectionMinimize = require('./src/golden-section-minimize');\nvar bracketMinimum = require('./src/bracket-minimum');\n\nvar bounds = [0, 0];\n\nmodule.exports = function minimize (f, options, status) {\n  options = options || {};\n  var x0;\n  var tolerance = options.tolerance === undefined ? 1e-8 : options.tolerance;\n  var dx = options.initialIncrement === undefined ? 1 : options.initialIncrement;\n  var xMin = options.lowerBound === undefined ? -Infinity : options.lowerBound;\n  var xMax = options.upperBound === undefined ? Infinity : options.upperBound;\n  var maxIterations = options.maxIterations === undefined ? 100 : options.maxIterations;\n\n  if (status) {\n    status.iterations = 0;\n    status.argmin = NaN;\n    status.minimum = Infinity;\n    status.converged = false;\n  }\n\n  if (isFinite(xMax) && isFinite(xMin)) {\n    bounds[0] = xMin;\n    bounds[1] = xMax;\n  } else {\n    // Construct the best guess we can:\n    if (options.guess === undefined) {\n      if (xMin > -Infinity) {\n        x0 = xMax < Infinity ? 0.5 * (xMin + xMax) : xMin;\n      } else {\n        x0 = xMax < Infinity ? xMax : 0;\n      }\n    } else {\n      x0 = options.guess;\n    }\n\n    bracketMinimum(bounds, f, x0, dx, xMin, xMax, maxIterations);\n\n    if (isNaN(bounds[0]) || isNaN(bounds[1])) {\n      return NaN;\n    }\n  }\n\n  return goldenSectionMinimize(f, bounds[0], bounds[1], tolerance, maxIterations, status);\n};\n","'use strict';\n\nmodule.exports = bracketMinimum;\n\nfunction bracketMinimum (bounds, f, x0, dx, xMin, xMax, maxIter) {\n  // If either size is unbounded (=infinite), Expand the guess\n  // range until we either bracket a minimum or until we reach the bounds:\n  var fU, fL, fMin, n, xL, xU, bounded;\n  n = 1;\n  xL = x0;\n  xU = x0;\n  fMin = fL = fU = f(x0);\n  while (!bounded && isFinite(dx) && !isNaN(dx)) {\n    ++n;\n    bounded = true;\n\n    if (fL <= fMin) {\n      fMin = fL;\n      xL = Math.max(xMin, xL - dx);\n      fL = f(xL);\n      bounded = false;\n    }\n    if (fU <= fMin) {\n      fMin = fU;\n      xU = Math.min(xMax, xU + dx);\n      fU = f(xU);\n      bounded = false;\n    }\n\n    // Track the smallest value seen so far:\n    fMin = Math.min(fMin, fL, fU);\n\n    // If either of these is the case, then the function appears\n    // to be minimized against one of the bounds, so although we\n    // haven't bracketed a minimum, we'll considere the procedure\n    // complete because we appear to have bracketed a minimum\n    // against a bound:\n    if ((fL === fMin && xL === xMin) || (fU === fMin && xU === xMax)) {\n      bounded = true;\n    }\n\n    // Increase the increment at a very quickly increasing rate to account\n    // for the fact that we have *no* idea what floating point magnitude is\n    // desirable. In order to avoid this, you should really provide *any\n    // reasonable bounds at all* for the variables.\n    dx *= n < 4 ? 2 : Math.exp(n * 0.5);\n\n    if (!isFinite(dx)) {\n      bounds[0] = -Infinity;\n      bounds[1] = Infinity;\n      return bounds;\n    }\n  }\n\n  bounds[0] = xL;\n  bounds[1] = xU;\n  return bounds;\n}\n","'use strict';\n\nvar PHI_RATIO = 2 / (1 + Math.sqrt(5));\n\nmodule.exports = goldenSectionMinimize;\n\nfunction goldenSectionMinimize (f, xL, xU, tol, maxIterations, status) {\n  var xF, fF;\n  var iteration = 0;\n  var x1 = xU - PHI_RATIO * (xU - xL);\n  var x2 = xL + PHI_RATIO * (xU - xL);\n  // Initial bounds:\n  var f1 = f(x1);\n  var f2 = f(x2);\n\n  // Store these values so that we can return these if they're better.\n  // This happens when the minimization falls *approaches* but never\n  // actually reaches one of the bounds\n  var f10 = f(xL);\n  var f20 = f(xU);\n  var xL0 = xL;\n  var xU0 = xU;\n\n  // Simple, robust golden section minimization:\n  while (++iteration < maxIterations && Math.abs(xU - xL) > tol) {\n    if (f2 > f1) {\n      xU = x2;\n      x2 = x1;\n      f2 = f1;\n      x1 = xU - PHI_RATIO * (xU - xL);\n      f1 = f(x1);\n    } else {\n      xL = x1;\n      x1 = x2;\n      f1 = f2;\n      x2 = xL + PHI_RATIO * (xU - xL);\n      f2 = f(x2);\n    }\n  }\n\n  xF = 0.5 * (xU + xL);\n  fF = 0.5 * (f1 + f2);\n\n  if (status) {\n    status.iterations = iteration;\n    status.argmin = xF;\n    status.minimum = fF;\n    status.converged = true;\n  }\n\n  if (isNaN(f2) || isNaN(f1) || iteration === maxIterations) {\n    if (status) {\n      status.converged = false;\n    }\n    return NaN;\n  }\n\n  if (f10 < fF) {\n    return xL0;\n  } else if (f20 < fF) {\n    return xU0;\n  } else {\n    return xF;\n  }\n}\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readNewick = exports.writeNexus = exports.writeNewick = exports.Tree = exports.Node = void 0;\nvar Node_1 = require(\"./Node\");\nObject.defineProperty(exports, \"Node\", { enumerable: true, get: function () { return Node_1.Node; } });\nvar Tree_1 = require(\"./Tree\");\nObject.defineProperty(exports, \"Tree\", { enumerable: true, get: function () { return Tree_1.Tree; } });\nvar Write_1 = require(\"./Write\");\nObject.defineProperty(exports, \"writeNewick\", { enumerable: true, get: function () { return Write_1.writeNewick; } });\nObject.defineProperty(exports, \"writeNexus\", { enumerable: true, get: function () { return Write_1.writeNexus; } });\nvar Reader_1 = require(\"./Reader\");\nObject.defineProperty(exports, \"readNewick\", { enumerable: true, get: function () { return Reader_1.readNewick; } });\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [974], function() { return __webpack_require__(76552); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"552\":\"d02f50a9\",\"974\":\"f330cd77\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t552: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkclockor2\"] = self[\"webpackChunkclockor2\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(974).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toPropertyKey","arg","key","input","hint","prim","toPrimitive","undefined","res","call","TypeError","String","Number","_defineProperty","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","require","linearRegression","points","reg","tip","x","y","sum_x","n","sum_y","sum_xy","sum_xx","sum_yy","j","slope","intercept","fitY","map","e","r2","Math","pow","sqrt","sigSq","a","reduce","b","logLik","log","mu","exp","PI","E","normalDensity","minimize","localRoot","tree","tipData","tipNames","getTipLabels","tipHeights","getRTTDist","dates","date","desc0","getSubtree","root","children","indicator","includes","bl","branchLength","len","EPSILON","console","alpha","name","univariateFunction","tipHeightsNew","lowerBound","upperBound","tolerance","maxIterations","self","onmessage","treePrime","localOptimum","best","data","nwk","nodeNums","readNewick","reroot","getNodeList","nodeIndx","postMessage","goldenSectionMinimize","bracketMinimum","bounds","module","exports","f","options","status","x0","dx","initialIncrement","xMin","Infinity","xMax","iterations","argmin","NaN","minimum","converged","isFinite","guess","isNaN","maxIter","fU","fL","fMin","xL","xU","bounded","max","min","PHI_RATIO","tol","xF","fF","iteration","x1","x2","f1","f2","f10","f20","xL0","xU0","abs","Node_1","Tree_1","Write_1","Reader_1","get","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","m","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","fulfilled","every","splice","r","chunkId","Promise","all","promises","u","miniCssF","o","prop","hasOwnProperty","p","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}