{"version":3,"file":"static/js/177.429421ee.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/typeof.js","../node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../node_modules/@babel/runtime/helpers/esm/objectSpread2.js","features/engine/core.ts","features/engine/bestFittingRoot.ts","features/engine/bfrWorker.ts","../node_modules/minimize-golden-section-1d/index.js","../node_modules/minimize-golden-section-1d/src/bracket-minimum.js","../node_modules/minimize-golden-section-1d/src/golden-section-minimize.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}","import defineProperty from \"./defineProperty.js\";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}","import { date_decimal } from \"./utils\";\nconst chroma = require(\"chroma-js\") // TODO: Learn about why this works instead of import\n\n// class to contain local clock model, incl. data points and information criteria\nexport interface LocalClockModel {\n  baseClock: Regression;\n  localClock: Regression[];\n  baseIC: InfoMetric;\n  localIC: InfoMetric;\n  groupNames: string[];\n}\n// interface for info metric data\nexport interface InfoMetric {\n  aic: number;\n  aicc: number;\n  bic: number;\n}\n\n// function to make plottable points\n// method for plotly plotting\nexport function plotify(lcm: LocalClockModel | null): any[] | null {\n  const plot = [] as any[];\n  if (lcm != null) {\n    // generate colour scale. Use viridis-ish default\n    const cols = lcm.localClock !== undefined\n      ?\n      chroma.scale(['#fafa6e', '#2A4858']).mode('lch').colors(lcm.localClock.length)\n      :\n      \"DarkSlateGrey\";\n\n    // Pushing plotly object for base lock\n    var point = {\n      x: lcm.baseClock.x.map(e => date_decimal(e)),\n      y: lcm.baseClock.y,\n      text: lcm.baseClock.tip,\n      marker: {color: '#000000', size: 7},\n      mode: \"markers\",\n      name: \"Global\",\n      legendgroup: \"Global\",\n      showlegend: false,\n      type: \"scattergl\"\n    }\n    plot.push(point);\n\n    var line = {\n      x: lcm.baseClock.x.map(e => date_decimal(e)),\n      y: lcm.baseClock.fitY,\n      name: \"Global\",\n      marker : {color: '#000000'},\n      mode: \"lines\",\n      text: lcm.localClock\n      ? \n        `Global<br>R2: ${lcm.baseClock.r2.toFixed(2)}` \n      : \n        `R2: ${lcm.baseClock.r2.toFixed(2)}`,\n\n      legendgroup: \"Global\",\n      type: \"scattergl\"\n    }\n    plot.push(line);\n\n    // pushing plotly object for each local clock\n    if (lcm.localClock){\n      for (let i = 0; i < lcm.localClock.length; i++) {\n        let legendGroup\n        if (lcm.groupNames[i+1] !== undefined) {\n          legendGroup = lcm.groupNames[i+1].length > 1 ? lcm.groupNames[i+1] : `Local Clock ${i+1}`\n        } else {\n          legendGroup = `Local Clock ${i+1}`;\n        }\n        \n        var point1 = {\n          x: lcm.localClock[i].x.map(e => date_decimal(e)),\n          y: lcm.localClock[i].y,\n          text: lcm.localClock[i].tip,\n          marker: {color: cols[i], line: {width: 1, color: 'DarkSlateGrey'}},\n          mode: \"markers\",\n          legendgroup: legendGroup,\n          name: lcm.groupNames[i+1],\n          showlegend: false,\n          type: \"scattergl\"\n        }\n        plot.push(point1);\n\n        var line1 = {\n          x: lcm.localClock[i].x.map(e => date_decimal(e)),\n          y: lcm.localClock[i].fitY,\n          text: `${lcm.groupNames[i+1] ?? `Local Clock ${i+1}`}<br>R2: ${lcm.localClock[i].r2.toFixed(2)}`,\n          marker : {color: cols[i], line: {width: 1, color: 'DarkSlateGrey'}},\n          mode: \"lines\",\n          legendgroup: legendGroup,\n          name: lcm.groupNames[i+1],\n          type: \"scattergl\"\n        }\n        plot.push(line1);\n      }\n    }\n      return plot;\n  } else {\n    return null;\n  }\n}\n\nexport interface Regression {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  fitY: Array<number>;\n  slope: number;\n  intercept: number;\n  sigSq: number;\n  r2: number;\n  logLik: number;\n  rms: number;\n}\n\n// Groups of points pertaining to one local clock\n// To be apended in array for linearRegression()\ninterface DataGroup {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  name: string;\n}\n\n//////////////////////////////////////////////////////\n// BELOW: CORE ENGINE FUNCTIONS SUCH AS SOMETHING() //\n// INCORPORATE FUNCTIONS DEFINED BELOW              //\n//////////////////////////////////////////////////////\n\n// Core function. Functionality for groups to be added\nexport const regression = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings: Array<string>,\n  tipNames: Array<string>) => {\n\n  var dataPoints = groupData(tipHeights, dates, groupings, tipNames);\n\n  var lcm = {} as LocalClockModel;\n  \n  lcm.baseClock = linearRegression(dataPoints[0]);\n  lcm.baseIC = {} as InfoMetric;\n  lcm.baseIC.aic = AIC([lcm.baseClock]);\n  lcm.baseIC.aicc = AICc([lcm.baseClock]);\n  lcm.baseIC.bic = BIC([lcm.baseClock]);\n\n  if (dataPoints.length > 1) {\n    lcm.localClock = dataPoints.slice(1).map(e => linearRegression(e));\n    lcm.localIC = {} as InfoMetric;\n    lcm.localIC.aic = AIC(lcm.localClock);\n    lcm.localIC.aicc = AICc(lcm.localClock);\n    lcm.localIC.bic = BIC(lcm.localClock);\n  }\n\n  lcm.groupNames = dataPoints.map(e => e.name)\n  \n  return lcm;\n}\n\n////////////////////////////////////////////////////////\n// BELOW: FUNCTIONS USED INSIDE CORE ENGINE FUNCTIONS //\n////////////////////////////////////////////////////////\n\n// function groups points for local clock regresion\n// 0th element of array is always points for single clock\nexport const groupData = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings:  Array<string>,\n  tipNames: Array<string>\n  ): DataGroup[] => { \n\n  const points: DataGroup[] = [];\n\n  let unique = groupings.filter((v, i, a) => a.indexOf(v) === i).sort();\n  let numericGroupings =  groupings.map(group => unique.indexOf(group))\n\n  for (let i = 0; i < unique.length; i++) {\n    var tmp: DataGroup = {x: [], y: [], tip: [], name: unique[i]};\n    points.push(tmp);\n  }\n\n  for (let i = 0; i < groupings.length; i++) {\n    points[numericGroupings[i]].x.push(\n      dates[i]\n    )\n    points[numericGroupings[i]].y.push(\n      tipHeights[i]\n    )\n    points[numericGroupings[i]].tip.push(\n      tipNames[i]\n    )\n  }\n  // if  num groups > 1, append the baseline fit (all points in one group)\n  // In the case num groups = 1, this is automatically appended\n  if (unique.length > 1) {\n    points.unshift({\n      x: dates,\n      y: tipHeights,\n      tip: tipNames,\n      name: \"Global\"\n    })}\n\n  return points;\n}\n\n// regression function \nexport function linearRegression(points: DataGroup) {\n  let reg = {} as Regression;\n\n  reg.tip = points.tip;\n\n  let x = points.x;\n  let y = points.y;\n\n  let sum_x = 0;\n  let n = y.length;\n  let sum_y = 0;\n  let sum_xy = 0;\n  let sum_xx = 0;\n  let sum_yy = 0;\n\n  for (let j = 0; j < y.length; j++) {\n      sum_x += x[j];\n      sum_y += y[j];\n      sum_xy += (x[j]*y[j]);\n      sum_xx += (x[j]*x[j]);\n      sum_yy += (y[j]*y[j]);\n  } \n\n  reg.x = x;\n  reg.y = y;\n  reg.slope = (n * sum_xy - sum_x * sum_y) / (n*sum_xx - sum_x * sum_x);\n  reg.intercept = (sum_y - reg.slope * sum_x)/n;\n  reg.fitY = x.map(e => (reg.slope * e + reg.intercept));\n  reg.r2 = Math.pow((n*sum_xy - sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);\n  \n  let error = y.map((n, i, a) => y[i] - reg.fitY[i]); \n  // estiamted variance of error\n  let sigSq = error.map(n => Math.pow(n, 2)).reduce(\n    (a, b) => a + b, 0) * (1 / reg.fitY.length);\n  reg.logLik = y.map((e, i) => Math.log(\n    normalDensity(e, reg.fitY[i], sigSq)\n    )\n    ).reduce(\n      (a, b) => a + b\n      ); \n\n  let rss = reg.fitY\n      .map((e,i) => e-reg.y[i])\n      .map(e => Math.pow(e,2))\n      .reduce((a,b) => a+b)\n  reg.rms = rss / (reg.y.length - 2);\n\n  return reg;\n}\n\n// Function for likelihood in linearRegression() function\n export function normalDensity(y: number, mu: number, sigSq: number) {\n  let exp = -0.5 * ((y - mu) ** 2) / sigSq; // exponent\n  let norm = 1 / (Math.sqrt(2 * Math.PI * sigSq)); // normalising factor\n  return norm * (Math.E ** exp);\n}\n\n// Information criteria functions below \nexport function AICc(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + ((6 * f * n) / (n - (3 * f) - 1))); \n}\n\nexport function AIC(regs: Regression[]): number {\n  var f = regs.length;\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + (6 * f)); \n}\n\nexport function BIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (3 * f * Math.log(n) - (2 * totLogLik)); \n}","import { linearRegression } from \"./core\";\nimport { Tree, readNewick, writeNewick } from \"phylojs\";\nvar minimize = require(\"minimize-golden-section-1d\");\n\nexport interface localOptima {\n  method: \"R2\" | \"RMS\";\n  value: number;\n  alpha: number;\n  nodeIndx: number;\n}\n\n/**\n * Creates a web worker for parallel processing and sets up message passing with the worker.\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @param {number[]} nodes - An array of node indices to be processed by the worker.\n * @returns {Promise} - A Promise that resolves with the worker's response data.\n */\nfunction createWorker(nwk: string, dates: number[], nodes: number[], tipData: any, bfrMode: \"R2\" | \"RMS\") {\n  return new Promise(function (resolve, reject) {\n    const worker = new Worker(new URL(\"./bfrWorker.ts\", import.meta.url));\n    worker.postMessage({\n      nwk: nwk,\n      dates: dates,\n      nodeNums: nodes,\n      tipData: tipData,\n      bfrMode: bfrMode\n    });\n    worker.onmessage = (e) => {\n      resolve(e.data);\n    };\n    worker.onerror = (e) => reject(e.error);\n  });\n}\n\n/**\n * Finds the best root for a phylogenetic tree by searching through all possible roots in parallel.\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @returns {Promise<string>} - A Promise that resolves with the Newick string of the best rooted tree.\n */\nexport async function globalRootParallel(nwk: string, dates: number[], tipData: any, bfrMode: \"R2\" | \"RMS\") {\n\n  var t0 = new Date().getTime();\n\n  const tree: Tree = readNewick(nwk);\n  var nodes = tree.getNodeList();\n  var nodeNums = nodes.map((e: any, i: number) => i).slice(1);\n\n  var nodeNumsChunked =\n    nodeNums.length > window.navigator.hardwareConcurrency\n      ?\n      spliceIntoChunks(\n        nodeNums,\n        (nodeNums.length - 1) / window.navigator.hardwareConcurrency\n      )\n      :\n      [nodeNums];\n\n  var promises = nodeNumsChunked.map((e: number[]) =>\n    createWorker(nwk, dates, e, tipData, bfrMode)\n  );\n\n  var prime = (await Promise.all(promises));\n\n  if (bfrMode == \"R2\") {\n    prime.unshift({\n      ...localRootR2(tree, tipData),\n      nodeIndx: 0,\n    })\n\n    let r2 = prime.map((e: any) => e.value);\n    let bestR2 = Math.max(...r2);\n    let bestIndx = r2.indexOf(bestR2);\n    var best: any = prime[bestIndx];\n\n  } else if (bfrMode == \"RMS\") {\n    prime.unshift({\n      ...localRootRMS(tree, tipData),\n      nodeIndx: 0,\n    })\n\n    let rss = prime.map((e: any) => e.value);\n    let minRSS = Math.min(...rss);\n    let bestIndx = rss.indexOf(minRSS);\n    var best: any = prime[bestIndx];\n  }\n\n  let bestTree = readNewick(nwk);\n\n  console.log(`Overall Best`)\n  console.log(best)\n  rerootAndScale(bestTree, best);\n\n  let t1 = new Date().getTime()\n\n  console.log(\"Time Taken for BFR \" + Math.abs(t1 - t0) / 1000 + \"s\")\n\n  bestTree.ladderise()\n  return writeNewick(bestTree);\n}\n\n/**\n * Reroots at best node and rescales basal branch lengths.\n * \n * @param {Tree} bestTree - The best rooted phylotree instance.\n * @param {any} best - The best local optima information.\n * @returns {void} - Only manipulates bestTree\n */\nexport function rerootAndScale(bestTree: Tree, best: any): void {\n\n  if (best.nodeIndx !== 0) {\n    bestTree.reroot(bestTree.getNodeList()[best.nodeIndx]);\n  }\n\n  let bl = bestTree.root.children.map(\n    e => e.branchLength\n  ).map(\n    e => e === undefined ? 0 : e\n  )\n  console.log(\"BL Reroot and rescale\")\n  console.log(bl)\n  let len = bl[0] + bl[1] // TODO: Ensure bifurcating here\n\n  let tLen1 = bestTree.getTotalBranchLength()\n\n  bestTree.root.children[0].branchLength = (best.alpha * len);\n  bestTree.root.children[1].branchLength = ((1 - best.alpha) * len);\n\n  let tlen2 = bestTree.getTotalBranchLength();\n\n  console.log(`Same Tree-length? : ${tLen1 - tlen2}`)\n}\n\n\n/**\n * Finds the best local root for a given phylogenetic tree base on R^{2}.\n *\n * @param {any} tree - A phylotree instance representing the phylogenetic tree.\n * @param {any} tipData - Object associating dates and tip names.\n * @returns {object} - An object containing the best alpha value and the corresponding R2 value.\n */\nexport function localRootR2(tree: Tree, tipData: any) {\n  var tipNames: string[] = tree.getTipLabels();\n  var tipHeights: number[] = tree.getRTTDist();\n  var dates = tipNames.map(e => tipData[e].date)\n\n  var desc0: string[] = tree.getSubtree(tree.root.children[0]).getTipLabels();\n\n  var indicator: number[] = [];\n  for (let i = 0; i < tipNames.length; i++) {\n    desc0.includes(tipNames[i]) ? indicator.push(1) : indicator.push(0);\n  }\n\n  let bl = tree.root.children.map(\n    e => e.branchLength\n  ).map(\n    e => e === undefined ? 0 : e\n  )\n  let len = bl.reduce((a, b) => a + b, 0)\n\n  // Skipping opimisation for effectively 0-length branches\n  // if (len < Number.EPSILON) {\n  //   console.log('BFR Skipping node! <==> Sum Basal Branch Lengths < Number.EPSILON');\n  //   return { \n  //     alpha: 0.5, \n  //     r2: linearRegression({ x: dates, y: tipHeights, tip: tipNames, name: 'NA' }).r2\n  //   }\n  // }\n\n  function univariateFunction(x: number) {\n    let tipHeightsNew = tipHeights.map((e, i) =>\n      indicator[i] * (e - bl[0] + (x * len)) +\n      (1 - indicator[i]) * (e - bl[1] + ((1 - x) * len))\n    );\n    return -1 * linearRegression({ x: dates, y: tipHeightsNew, tip: tipNames, name: 'NA' }).r2;\n  };\n\n  let alpha = minimize(univariateFunction, { lowerBound: 0, upperBound: 1, tolerance: Number.EPSILON, maxIterations: 1000 });\n\n  return { alpha: alpha, value: -1 * univariateFunction(alpha), method: \"R2\" };\n\n}\n\n/**\n * Finds scalar of basal branch length to place root with RMS optimisation.\n *\n * @param {number[]} y - Starting RTT distances. Hoist to one side.\n * @param {number[]} t - Tip Dates.\n * @param {number[]} c - Indicator for which side of the root (Left/Right) that tips descend from.\n * @returns {number}  - Optimal proportion.\n */\nexport function bfrPropRMS(y: number[], t: number[], c: number[]) {\n  c = c.map((e) => -1 * ((2 * e) - 1));\n  const N: number = y.length;\n  const t_bar: number = t.reduce((a, b) => a + b, 0) / N;\n  const d_bar: number = y.reduce((a, b) => a + b, 0) / N;\n  const c_bar: number = c.reduce((a, b) => a + b, 0) / N;\n\n  const Sdc: number = sumProduct(y.map((e) => d_bar - e), c.map((e) => c_bar - e));\n  const Scc: number = sumProduct(c.map((e) => c_bar - e), c.map((e) => c_bar - e));\n  const Std: number = sumProduct(t.map((e) => t_bar - e), y.map((e) => d_bar - e));\n  const Stc: number = sumProduct(t.map((e) => t_bar - e), c.map((e) => c_bar - e));\n  const Stt: number = sumProduct(t.map((e) => t_bar - e), t.map((e) => t_bar - e));\n\n  const num: number = Sdc - (Std * Stc / Stt);\n  const den: number = Scc - (Stc * Stc / Stt);\n\n  return num / den;\n}\n\n\n// Auxiliary \nexport function sumProduct(arr1: number[], arr2?: number[]): number {\n    if (arr2) {\n        return arr1.reduce((acc, curr, index) => acc + curr * arr2[index], 0);\n    }\n    return arr1.reduce((acc, curr) => acc + curr, 0);\n}\n\n/**\n * Finds the best local root for a given phylogenetic tree base on residual sum of swuares.\n *\n * @param {any} tree - A phylotree instance representing the phylogenetic tree.\n * @param {any} tipData - Object associating dates and tip names.\n * @returns {object} - An object containing the best alpha value and the corresponding R2 value.\n */\nexport function localRootRMS(tree: Tree, tipData: any) {\n  // TODO: There is a lot of \"1-x\" stuff below. Refactor later to just work in terms of x / alpha\n  var tipNames: string[] = tree.getTipLabels();\n  var tipHeights: number[] = tree.getRTTDist();\n  var t = tipNames.map(e => tipData[e].date)\n\n  var leftBranchTips: string[] = tree.getSubtree(tree.root.children[0]).getTipLabels();\n  var c: number[] = [];\n  for (let i = 0; i < tipNames.length; i++) {\n    leftBranchTips.includes(tipNames[i]) ? c.push(0) : c.push(1);\n    //leftBranchTips.includes(tipNames[i]) ? c.push(1) : c.push(0);\n  }\n\n  let bl = tree.root.children.map(\n    e => e.branchLength\n  ).map(\n    e => e === undefined ? 0 : e\n  )\n  if (bl.length > 2) console.warn(\"BFR: More than 2 child branches!\")\n  //let sumLength = bl.reduce((a, b) => a + b, 0)\n  let sumLength = bl[0] + bl[1]\n\n  let y = tipHeights;\n  // Hoist all basal branch length to right\n  for (let j = 0; j < y.length; j++) { \n    y[j] = y[j] + (1-c[j])*(sumLength-bl[0]) - c[j]*(sumLength-bl[0]);\n    //y[j] = y[j] + (1-c[j])*(bl[0]) - c[j]*(bl[0]);\n  }\n\n  let x = bfrPropRMS(y, t, c) / sumLength;\n  x = Math.min(Math.max(x, 0.0), 1.0);\n  let alpha = 1-x;\n  //let alpha = x;\n\n  // rms\n  let yPrime = y.map((e,i) => e + c[i]*((1-alpha)*sumLength) - (1-c[i])*((1-alpha)*sumLength))\n  //let yPrime = y.map((e,i) => e + c[i]*(alpha*sumLength) - (1-c[i])*(alpha*sumLength))\n\n  let rms = linearRegression({ x: t, y: yPrime, tip: tipNames, name: 'NA' }).rms\n\n  return { alpha: alpha, value: rms, method: \"RMS\" };\n}\n\n/**\n * Splits an array into chunks of the specified size.\n *\n * @param {number[]} arr - The array to be split into chunks.\n * @param {number} chunkSize - The size of each chunk.\n * @returns {number[][]} - An array of chunks.\n */\nexport function spliceIntoChunks(arr: number[], chunkSize: number) {\n  const res = [];\n  while (arr.length > 0) {\n    const chunk = arr.splice(0, chunkSize);\n    res.push(chunk);\n  }\n  return res;\n}","import { localRootR2, localRootRMS, localOptima } from \"./bestFittingRoot\";\nimport { readNewick, Tree } from \"phylojs\";\n\n\n// this runs on the webworker, created with webpack 5 syntax new\n// Worker('./worker.ts'). in jest tests, this module is not used, instead the\n// workerMessageHandler is directly addressed\nself.onmessage = ({ data: { nwk, nodeNums, tipData, bfrMode } }) => { /* eslint-disable-line no-restricted-globals */\n  var treePrime: Tree\n  var localOptimum: localOptima\n  var best: localOptima\n\n  // first node case\n  treePrime = readNewick(nwk);\n  const nodes = treePrime.getNodeList();\n\n  treePrime.reroot(nodes[nodeNums[0]]);\n\n  if (bfrMode == \"R2\") {\n    best = {\n      ...localRootR2(\n        treePrime,\n        tipData\n      ),\n      nodeIndx: nodeNums[0],\n      method: \"R2\"\n    }\n\n    // compare to rest of nodes\n    for (let i=1; i<nodeNums.length; i++) {\n      \n      treePrime.reroot(nodes[nodeNums[i]]);\n\n      localOptimum = {\n        ...localRootR2(\n          treePrime,\n          tipData\n        ),\n        nodeIndx: nodeNums[i],\n        method: \"R2\"\n      }\n\n      if (localOptimum.value - best.value > 0) {\n        best = localOptimum;\n      }\n    }\n\n    self.postMessage(best); /* eslint-disable-line no-restricted-globals */\n  \n  } else if (bfrMode == \"RMS\") {\n    best = {\n      ...localRootRMS(\n        treePrime,\n        tipData\n      ),\n      nodeIndx: nodeNums[0],\n      method: \"RMS\"\n    }\n\n    // compare to rest of nodes\n    for (let i=1; i<nodeNums.length; i++) {\n\n      treePrime.reroot(nodes[nodeNums[i]]);\n\n      localOptimum = {\n        ...localRootRMS(\n          treePrime,\n          tipData\n        ),\n        nodeIndx: nodeNums[i],\n        method: \"RMS\"\n      }\n\n      if (best.value - localOptimum.value > 0) {\n        best = localOptimum;\n      }\n    }\n\n    self.postMessage(best); /* eslint-disable-line no-restricted-globals */\n  }\n}; ","'use strict';\n\nvar goldenSectionMinimize = require('./src/golden-section-minimize');\nvar bracketMinimum = require('./src/bracket-minimum');\n\nvar bounds = [0, 0];\n\nmodule.exports = function minimize (f, options, status) {\n  options = options || {};\n  var x0;\n  var tolerance = options.tolerance === undefined ? 1e-8 : options.tolerance;\n  var dx = options.initialIncrement === undefined ? 1 : options.initialIncrement;\n  var xMin = options.lowerBound === undefined ? -Infinity : options.lowerBound;\n  var xMax = options.upperBound === undefined ? Infinity : options.upperBound;\n  var maxIterations = options.maxIterations === undefined ? 100 : options.maxIterations;\n\n  if (status) {\n    status.iterations = 0;\n    status.argmin = NaN;\n    status.minimum = Infinity;\n    status.converged = false;\n  }\n\n  if (isFinite(xMax) && isFinite(xMin)) {\n    bounds[0] = xMin;\n    bounds[1] = xMax;\n  } else {\n    // Construct the best guess we can:\n    if (options.guess === undefined) {\n      if (xMin > -Infinity) {\n        x0 = xMax < Infinity ? 0.5 * (xMin + xMax) : xMin;\n      } else {\n        x0 = xMax < Infinity ? xMax : 0;\n      }\n    } else {\n      x0 = options.guess;\n    }\n\n    bracketMinimum(bounds, f, x0, dx, xMin, xMax, maxIterations);\n\n    if (isNaN(bounds[0]) || isNaN(bounds[1])) {\n      return NaN;\n    }\n  }\n\n  return goldenSectionMinimize(f, bounds[0], bounds[1], tolerance, maxIterations, status);\n};\n","'use strict';\n\nmodule.exports = bracketMinimum;\n\nfunction bracketMinimum (bounds, f, x0, dx, xMin, xMax, maxIter) {\n  // If either size is unbounded (=infinite), Expand the guess\n  // range until we either bracket a minimum or until we reach the bounds:\n  var fU, fL, fMin, n, xL, xU, bounded;\n  n = 1;\n  xL = x0;\n  xU = x0;\n  fMin = fL = fU = f(x0);\n  while (!bounded && isFinite(dx) && !isNaN(dx)) {\n    ++n;\n    bounded = true;\n\n    if (fL <= fMin) {\n      fMin = fL;\n      xL = Math.max(xMin, xL - dx);\n      fL = f(xL);\n      bounded = false;\n    }\n    if (fU <= fMin) {\n      fMin = fU;\n      xU = Math.min(xMax, xU + dx);\n      fU = f(xU);\n      bounded = false;\n    }\n\n    // Track the smallest value seen so far:\n    fMin = Math.min(fMin, fL, fU);\n\n    // If either of these is the case, then the function appears\n    // to be minimized against one of the bounds, so although we\n    // haven't bracketed a minimum, we'll considere the procedure\n    // complete because we appear to have bracketed a minimum\n    // against a bound:\n    if ((fL === fMin && xL === xMin) || (fU === fMin && xU === xMax)) {\n      bounded = true;\n    }\n\n    // Increase the increment at a very quickly increasing rate to account\n    // for the fact that we have *no* idea what floating point magnitude is\n    // desirable. In order to avoid this, you should really provide *any\n    // reasonable bounds at all* for the variables.\n    dx *= n < 4 ? 2 : Math.exp(n * 0.5);\n\n    if (!isFinite(dx)) {\n      bounds[0] = -Infinity;\n      bounds[1] = Infinity;\n      return bounds;\n    }\n  }\n\n  bounds[0] = xL;\n  bounds[1] = xU;\n  return bounds;\n}\n","'use strict';\n\nvar PHI_RATIO = 2 / (1 + Math.sqrt(5));\n\nmodule.exports = goldenSectionMinimize;\n\nfunction goldenSectionMinimize (f, xL, xU, tol, maxIterations, status) {\n  var xF, fF;\n  var iteration = 0;\n  var x1 = xU - PHI_RATIO * (xU - xL);\n  var x2 = xL + PHI_RATIO * (xU - xL);\n  // Initial bounds:\n  var f1 = f(x1);\n  var f2 = f(x2);\n\n  // Store these values so that we can return these if they're better.\n  // This happens when the minimization falls *approaches* but never\n  // actually reaches one of the bounds\n  var f10 = f(xL);\n  var f20 = f(xU);\n  var xL0 = xL;\n  var xU0 = xU;\n\n  // Simple, robust golden section minimization:\n  while (++iteration < maxIterations && Math.abs(xU - xL) > tol) {\n    if (f2 > f1) {\n      xU = x2;\n      x2 = x1;\n      f2 = f1;\n      x1 = xU - PHI_RATIO * (xU - xL);\n      f1 = f(x1);\n    } else {\n      xL = x1;\n      x1 = x2;\n      f1 = f2;\n      x2 = xL + PHI_RATIO * (xU - xL);\n      f2 = f(x2);\n    }\n  }\n\n  xF = 0.5 * (xU + xL);\n  fF = 0.5 * (f1 + f2);\n\n  if (status) {\n    status.iterations = iteration;\n    status.argmin = xF;\n    status.minimum = fF;\n    status.converged = true;\n  }\n\n  if (isNaN(f2) || isNaN(f1) || iteration === maxIterations) {\n    if (status) {\n      status.converged = false;\n    }\n    return NaN;\n  }\n\n  if (f10 < fF) {\n    return xL0;\n  } else if (f20 < fF) {\n    return xU0;\n  } else {\n    return xF;\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [495], function() { return __webpack_require__(46177); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"177\":\"429421ee\",\"495\":\"32464121\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t177: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkclockor2\"] = self[\"webpackChunkclockor2\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(495).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toPropertyKey","arg","key","input","hint","prim","toPrimitive","undefined","res","call","TypeError","String","Number","_defineProperty","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","require","linearRegression","points","reg","tip","x","y","sum_x","n","sum_y","sum_xy","sum_xx","sum_yy","j","slope","intercept","fitY","map","e","r2","Math","pow","sqrt","sigSq","a","reduce","b","logLik","log","mu","exp","PI","E","normalDensity","rss","rms","minimize","localRootR2","tree","tipData","tipNames","getTipLabels","tipHeights","getRTTDist","dates","date","desc0","getSubtree","root","children","indicator","includes","bl","branchLength","len","univariateFunction","tipHeightsNew","name","alpha","lowerBound","upperBound","tolerance","EPSILON","maxIterations","method","sumProduct","arr1","arr2","acc","curr","index","localRootRMS","t","leftBranchTips","c","console","warn","sumLength","N","t_bar","d_bar","c_bar","Sdc","Scc","Std","Stc","Stt","bfrPropRMS","min","max","yPrime","self","onmessage","treePrime","localOptimum","best","data","nwk","nodeNums","bfrMode","nodes","readNewick","getNodeList","reroot","nodeIndx","postMessage","goldenSectionMinimize","bracketMinimum","bounds","module","exports","f","options","status","x0","dx","initialIncrement","xMin","Infinity","xMax","iterations","argmin","NaN","minimum","converged","isFinite","guess","isNaN","maxIter","fU","fL","fMin","xL","xU","bounded","PHI_RATIO","tol","xF","fF","iteration","x1","x2","f1","f2","f10","f20","xL0","xU0","abs","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","m","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","fulfilled","every","splice","r","chunkId","Promise","all","promises","u","miniCssF","o","prop","hasOwnProperty","p","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}