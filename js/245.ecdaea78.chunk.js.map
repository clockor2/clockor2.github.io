{"version":3,"file":"static/js/245.ecdaea78.chunk.js","mappings":"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","sources":["features/engine/core.ts","features/engine/utils.ts","features/engine/bestFittingRoot.ts","features/engine/bfrWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { date_decimal } from \"./utils\";\nconst chroma = require(\"chroma-js\") // TODO: Learn about why this works instead of import\n\n// class to contain local clock model, incl. data points and information criteria\nexport interface LocalClockModel {\n  baseClock: Regression;\n  localClock: Regression[];\n  baseIC: InfoMetric;\n  localIC: InfoMetric;\n  groupNames: string[];\n}\n// interface for info metric data\ninterface InfoMetric {\n  aic: number;\n  aicc: number;\n  bic: number;\n}\n\n// function to make plottable points\n// method for plotly plotting\nexport function plotify(lcm: LocalClockModel | null): Plotly.Data[] | null {\n  const plot = [] as Plotly.Data[];\n  if (lcm != null) {\n    // generate colour scale. Use viridis-ish default\n    const cols = lcm.localClock\n      ?\n      chroma.scale(['#fafa6e', '#2A4858']).mode('lch').colors(lcm.localClock.length)\n      :\n      \"DarkSlateGrey\";\n\n    // Pushing plotly object for base lock\n    var point = {\n      x: lcm.baseClock.x.map(e => date_decimal(e)),\n      y: lcm.baseClock.y,\n      text: lcm.baseClock.tip,\n      marker: {color: '#000000', size: 5},\n      mode: \"markers\",\n      name: \"Global\",\n      legendgroup: \"Global\",\n      showlegend: false\n    }\n    plot.push(point);\n\n    var line = {\n      x: lcm.baseClock.x.map(e => date_decimal(e)),\n      y: lcm.baseClock.fitY,\n      name: \"Global\",\n      marker : {color: '#000000'},\n      mode: \"lines\",\n      text: lcm.localClock\n      ? \n        `Global<br>R2: ${lcm.baseClock.r2.toFixed(2)}` \n      : \n        `R2: ${lcm.baseClock.r2.toFixed(2)}`,\n\n      legendgroup: \"Global\"\n    }\n    plot.push(line);\n\n    // pushing plotly object for each local clock\n    if (lcm.localClock){\n      for (let i = 0; i < lcm.localClock.length; i++) {\n        var point1 = {\n          x: lcm.localClock[i].x.map(e => date_decimal(e)),\n          y: lcm.localClock[i].y,\n          text: lcm.localClock[i].tip,\n          marker: {color: cols[i], line: {width: 1, color: 'DarkSlateGrey'}},\n          mode: \"markers\",\n          legendgroup: lcm.groupNames[i+1].length > 1 ? lcm.groupNames[i+1] : `Local Clock ${i+1}`,\n          name: lcm.groupNames[i+1],\n          showlegend: false\n        }\n        plot.push(point1);\n\n        var line1 = {\n          x: lcm.localClock[i].x.map(e => date_decimal(e)),\n          y: lcm.localClock[i].fitY,\n          text: `${lcm.groupNames[i+1] ?? `Local Clock ${i+1}`}<br>R2: ${lcm.localClock[i].r2.toFixed(2)}`,\n          marker : {color: cols[i], line: {width: 1, color: 'DarkSlateGrey'}},\n          mode: \"lines\",\n          legendgroup: lcm.groupNames[i+1].length > 1 ? lcm.groupNames[i+1] : `Local Clock ${i+1}`,\n          name: lcm.groupNames[i+1]\n        }\n        plot.push(line1);\n      }\n    }\n      return plot;\n  } else {\n    return null;\n  }\n  }\n\n\n\ninterface Style {\n  color: string;\n}\n\nexport interface Regression {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  fitY: Array<number>;\n  slope: number;\n  intercept: number;\n  sigSq: number;\n  r2: number;\n  logLik: number;\n}\n\n// Groups of points pertaining to one local clock\n// To be apended in array for linearRegression()\ninterface DataGroup {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  name: string;\n}\n\n//////////////////////////////////////////////////////\n// BELOW: CORE ENGINE FUNCTIONS SUCH AS SOMETHING() //\n// INCORPORATE FUNCTIONS DEFINED BELOW              //\n//////////////////////////////////////////////////////\n\n// Core function. Functionality for groups to be added\nexport const regression = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings: Array<string>,\n  tipNames: Array<string>) => {\n\n  var dataPoints = groupData(tipHeights, dates, groupings, tipNames);\n\n  var lcm = {} as LocalClockModel;\n  \n  lcm.baseClock = linearRegression(dataPoints[0]);\n  lcm.baseIC = {} as InfoMetric;\n  lcm.baseIC.aic = AIC([lcm.baseClock]);\n  lcm.baseIC.aicc = AICc([lcm.baseClock]);\n  lcm.baseIC.bic = BIC([lcm.baseClock]);\n\n  if (dataPoints.length > 1) {\n    lcm.localClock = dataPoints.slice(1).map(e => linearRegression(e));\n    lcm.localIC = {} as InfoMetric;\n    lcm.localIC.aic = AIC(lcm.localClock);\n    lcm.localIC.aicc = AICc(lcm.localClock);\n    lcm.localIC.bic = BIC(lcm.localClock);\n  }\n\n  lcm.groupNames = dataPoints.map(e => e.name)\n  \n  return lcm;\n}\n\n// Clock search function. Conver to a generator later\n// icMetric is the information criterion used to find 'best' state. TODO: Need to read these as part of input: aic | aicc | bic\n// export const clockSearch = (tree: any,\n//   minCladeSize: number,\n//   numClocks: number,\n//   tipHeights: Array<number>,\n//   dates: Array<number>,\n//   tipNames: Array<string>,\n//   icMetric: string) => {\n\n//   // generate all possibilities for groupings\n//   let allGroups = getGroups(tree, minCladeSize, numClocks);\n//   let allGroupsNumber = allGroups.map((e: string[][]) => groupToNum(e, tips));\n\n//   // Loop through group possibilities and append to fits\n//   let fits: LocalClockModel[] = [];\n//   for (let i = 0; i < allGroups.length; i++){\n//       fits.push(regression(tipHeights, dates, allGroups[i], tipNames)); \n//   }\n\n//   // Now find the most supported configuration\n//   // Getting array of IC values based on selected IC TODO: Add capability for multiple ICs\n//   const ic = fits.map(e => e[icMetric as keyof LocalClockModel]) // TODO: Test here!\n\n//   var icMaxStep = ic.indexOf(Math.max(...(ic as number[]))); // TODO: This might throw an error if we never see output\n\n//   return fits[icMaxStep];\n// }\n\n////////////////////////////////////////////////////////\n// BELOW: FUNCTIONS USED INSIDE CORE ENGINE FUNCTIONS //\n////////////////////////////////////////////////////////\n\n// function groups points for local clock regresion\n// 0th element of array is always points for single clock\nconst groupData = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings:  Array<string>,\n  tipNames: Array<string>\n  ): DataGroup[] => { \n\n  const points: DataGroup[] = [];\n\n  let unique = groupings.filter((v, i, a) => a.indexOf(v) === i).sort();\n  let numericGroupings =  groupings.map(group => unique.indexOf(group))\n\n  for (let i = 0; i < unique.length; i++) {\n    var tmp: DataGroup = {x: [], y: [], tip: [], name: unique[i]};\n    points.push(tmp);\n  }\n\n  for (let i = 0; i < groupings.length; i++) {\n    points[numericGroupings[i]].x.push(\n      dates[i]\n    )\n    points[numericGroupings[i]].y.push(\n      tipHeights[i]\n    )\n    points[numericGroupings[i]].tip.push(\n      tipNames[i]\n    )\n  }\n  // if  num groups > 1, append the baseline fit (all points in one group)\n  // In the case num groups = 1, this is automatically appended\n  if (unique.length > 1) {\n    points.unshift({\n      x: dates,\n      y: tipHeights,\n      tip: tipNames,\n      name: \"Global\"\n    })}\n\n  return points;\n}\n\n// regression function \nexport function linearRegression(points: DataGroup) {\n  let reg = {} as Regression;\n\n  // carrying tips over first\n  reg.tip = points.tip;\n\n  let x = points.x;\n  let y = points.y;\n\n  let sum_x = 0;\n  let n = y.length;\n  let sum_y = 0;\n  let sum_xy = 0;\n  let sum_xx = 0;\n  let sum_yy = 0;\n\n  for (let j = 0; j < y.length; j++) {\n      sum_x += x[j];\n      sum_y += y[j];\n      sum_xy += (x[j]*y[j]);\n      sum_xx += (x[j]*x[j]);\n      sum_yy += (y[j]*y[j]);\n  } \n\n  // Include these later after agreeing on how to pass to front end\n  reg.x = x;\n  reg.y = y;\n  reg.slope = (n * sum_xy - sum_x * sum_y) / (n*sum_xx - sum_x * sum_x);\n  reg.intercept = (sum_y - reg.slope * sum_x)/n;\n  reg.fitY = x.map(e => (reg.slope * e + reg.intercept));\n  reg.r2 = Math.pow((n*sum_xy - sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);\n  //calculate log likelihood\n  \n  let error = y.map((n, i, a) => y[i] - reg.fitY[i]); \n  // estiamted variance of error\n  let sigSq = error.map(n => Math.pow(n, 2)).reduce(\n    (a, b) => a + b, 0) * (1 / reg.fitY.length);\n  //reg.logLik = y.map((e, i) => Math.log(normalDensity(e, reg.fitY[i], sigSq))).reduce((a, b) => a + b); \n  reg.logLik = y.map((e, i) => Math.log(\n    normalDensity(e, reg.fitY[i], sigSq)\n    )\n    ).reduce(\n      (a, b) => a + b\n      ); \n\n  return reg;\n}\n\n// Function for likelihood in linearRegression() function\n export function normalDensity(y: number, mu: number, sigSq: number) {\n  let exp = -0.5 * ((y - mu) ** 2) / sigSq; // exponent\n  let norm = 1 / (Math.sqrt(2 * Math.PI * sigSq)); // normalising factor\n  return norm * (Math.E ** exp);\n}\n\n// Information criteria functions below \nexport function AICc(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + ((6 * f * n) / (n - (3 * f) - 1))); \n}\n\nexport function AIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + (6 * f)); \n}\n\nexport function BIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (3 * f * Math.log(n) - (2 * totLogLik)); \n}\n\nexport function getGroups (tree: any, minCladeSize: number, numClocks: number): string[][][] {\n  // Sets of tips descending from each node\n  var tips: any = [];\n  // list tips descending from each node\n  tree.nodes.each((node: any) => tips.push(node.leaves())); \n  // map to just tip names\n  var tips = tips.map((e0: any) => e0.map((e1: any) => e1.data.name));\n  // De-duplicate tips (artefact from d3 hierarchy)\n  var uniqueTips = tips.map(\n    (e: string[]) => JSON.stringify(e)\n    ).filter(\n      (e: string[], i: number, a: string[][]) => {return a.indexOf(e) === i}\n      ).map(\n       (e: string) => JSON.parse(e)\n        )\n  // Sort clades based on size. Largest (all tips) goes first\n  var sortedUniqueTips = uniqueTips.sort((a: string[], b: string[]) => {return b.length - a.length});\n\n  // Filter out all clades with fewer than ${minCladeSize} tips\n  var finalClades = sortedUniqueTips.filter((e: string[]) => e.length >= minCladeSize);\n\n  // array from 1:(finalClades.length) possible clades to draw combinations\n  var grpNums = Array.from(Array(finalClades.length).keys());\n  // +1 to account for 0th base clock\n  //var grpNums = grpNums.map((e: number, i: number ) => i+1); \n  \n  // remove 0th group - that being all tips. Add back in later\n  grpNums.shift()\n  // get all combinations of groups to make up ${numClocks} local clocks\n  let comb = combn(grpNums, (numClocks - 1))\n  // add 0th clade for background rate\n  comb.map((e: number[]) => e.unshift(0)); \n\n  // Convert number combinations to corresponding groups of tips\n  let allGroups: string[][][] = [];\n  for (let i = 0; i < comb.length; i++){\n    allGroups.push(\n      comb[i].map(\n        (e: number) => finalClades[e]\n      )\n    );\n  }\n\n  //return groups after converting to non-intersecting groups;\n  return allGroups.map(e => getUnique(e));\n\n  // TODO: Size-filtering and defend against requesting too many clocks\n}\n\n// function takes string[][] and maps each to unique values assuming each string[] is nested as for allGroups\nexport function getUnique(x: string[][]): string[][] {\n  return x.map((e0: string[], i) => e0.filter(\n      (e1: string) => {\n        if(i+1 < x.length) { \n          return !x[i+1].includes(e1); \n        } else {\n          return true;\n        }\n      })\n  );\n}\n\n// A function that takes a list of tips and returns group number based on an element of allGroups\nfunction groupToNum(arr: string[][], tips: string[]): number[] {\n    let groupings: number[] = []; \n\n    for (let i = 0; i < tips.length; i++){\n      var tmp = [];\n      \n      for (let j = 0; j < arr.length; j++) {\n        if (arr[j].indexOf(tips[i]) > -1) {\n          groupings[i] = j;\n        } \n      }\n    }\n  return groupings;\n} // TODO: Include a test here to check that output is all integers and that ordering of tips matches input\n\n\n// generating combinations of groups\n export function combn(arr: any[], k: number): number[][] {\n  // Store all possible combinations in a result array\n  const result: number[][] = [];\n\n  // Generate all combinations using a recursive helper function\n  function generateCombinations(currentIndex: number, currentCombination: any[]): void {\n    // If the current combination has the desired length, add it to the result array\n    if (currentCombination.length === k) {\n      result.push(currentCombination);\n      return;\n    }\n\n    // Generate all possible combinations starting from the next element in the array\n    for (let i = currentIndex; i < arr.length; i++) {\n      generateCombinations(i + 1, currentCombination.concat(arr[i]));\n    }\n  }\n\n  // Start the recursive process with the first element in the array\n  generateCombinations(0, []);\n\n  // Return the result array\n  return result;\n}\n","\nexport const decimal_date = (sampDate: string, format: \"yyyy-mm-dd\" | \"decimal\") => {\n  if (format === \"yyyy-mm-dd\"){\n      let date = new Date(sampDate)\n      let yr = date.getFullYear();\n      let m = date.getMonth() ?? 0;\n      let d = date.getDate() ?? 0;\n\n      let decimal_date_value = (\n        yr +\n        m / 12 +\n        d / 365.25\n      )\n\n      return decimal_date_value;\n  } else  {\n    let decimal_date = parseFloat(sampDate) \n    return decimal_date\n  }\n  };\n\nexport const date_decimal = (sampDate: number): Date => {\n    var year = parseInt(sampDate.toString());\n    var reminder = sampDate - year;\n    var daysPerYear = 365.25\n    var miliseconds = reminder * daysPerYear * 24 * 60 * 60 * 1000;\n    var yearDate = new Date(year, 0, 1);\n    return new Date(yearDate.getTime() + miliseconds);\n};\n\nexport const createGroups = (decimal_dates:number[], tipHeights: number[], tipNames: number[], groupings:number[]) => {\n    /**\n     * Splits arrays into groups \n     * This method returns a array of group objects\n     */\n    let unique = groupings.filter((v, i, a) => a.indexOf(v) === i);\n    let groups = unique.map(() => {return {tipHeights:[] as number[], decimal_dates:[] as number[], tipNames: [] as number[]}})\n\n    for (let index = 0; index < groupings.length; index++) {\n      groups[groupings[index]].decimal_dates.push(\n        decimal_dates[index]\n      )\n      groups[groupings[index]].tipHeights.push(\n        tipHeights[index]\n      )\n      groups[groupings[index]].tipNames.push(\n        tipNames[index]\n      )\n    }\n    return groups\n  }\n\n  interface TreeNode {\n    data: {\n      name: string;\n      attribute?: number;\n    };\n    children?: TreeNode[];\n\n  }\n  function dfs(tree: any, node: TreeNode, distanceFromRoot: number, leafDistances: Map<string, number>): Map<string, number> {\n    if (!node.children || node.children.length === 0) {\n      leafDistances.set(node.data.name, distanceFromRoot);\n    } else {\n      node.children.forEach((child) => {\n        const distance = Number(tree.branch_length_accessor(child)) || 0;\n        dfs(tree, child, distanceFromRoot + distance, leafDistances);\n      });\n    }\n    return leafDistances;\n  }\n  \n  export function computeDistances(tree: any): Map<string, number> {\n    const leafDistances = new Map<string, number>();\n    return dfs(tree, tree.nodes, 0, leafDistances);\n  }\n\n  export const getTipHeights = (tree: any): number[] => {\n    let distances = computeDistances(tree)\n    return tree.getTips().map((tip: any) => distances.get(tip.data.name)) // reorder the nodes \n  }\n\n  export const getTipNames = (tree: any): string[] => {\n    return tree.getTips().map((tip: any) => tip.data.name);\n  }\n\n  export function rootToNodeDistance(tree: any, nodeNum: number) {\n    let node = tree.nodes.descendants()[nodeNum];\n    let dist = 0;\n    while(node) {\n      if (tree.branch_length_accessor(node)) {\n        dist += tree.branch_length_accessor(node)\n      } else {\n        dist += 0\n      }\n\n      node = node.parent;\n    }\n\n    return dist;\n  }\n\n  export function rootTipDistances(tree: any) {\n\n    tree.nodes.each((n: any) => {\n      if (n.parent) {\n        n.data.rootDist = Number(tree.branch_length_accessor(n)) + n.parent.data.rootDist;\n      } else {\n        n.data.rootDist = 0\n      }\n    })\n\n    let rootDists = tree.getTips().map((e: any) => e.data.rootDist)\n    return rootDists;\n\n  }\n\n  export function getLength(tree: any) {\n\n    return tree.nodes.descendants().slice(1).map(\n      (n: any) => tree.branch_length_accessor(n)\n    ).reduce(\n      (a: number, b: number) => a+b\n    )\n\n  }","import { phylotree } from \"phylotree\";\nimport { linearRegression } from \"./core\";\nimport { getTipHeights, getTipNames, computeDistances, getLength } from \"./utils\";\nimport { useAppSelector } from \"../../app/hooks\";\nimport { selectTipData } from \"../tree/treeSlice\";\nimport { regression } from \"../engine/core\";\n\nvar minimize = require(\"minimize-golden-section-1d\");\n\nexport interface localOptima {\n  r2: number;\n  alpha: number;\n  nodeIndx: number;\n}\n\n/**\n * Creates a web worker for parallel processing and sets up message passing with the worker.\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @param {number[]} nodes - An array of node indices to be processed by the worker.\n * @returns {Promise} - A Promise that resolves with the worker's response data.\n */\nfunction createWorker(nwk: string, dates: number[], nodes: number[], tipData: any) {\n  return new Promise(function (resolve, reject) {\n    const worker = new Worker(new URL(\"./bfrWorker.ts\", import.meta.url));\n    worker.postMessage({\n      nwk: nwk,\n      dates: dates,\n      nodeNums: nodes,\n      tipData: tipData\n    });\n    worker.onmessage = (e) => {\n      resolve(e.data);\n    };\n    worker.onerror = (e) => reject(e.error);\n  });\n}\n\n/**\n * Finds the best root for a phylogenetic tree by searching through all possible roots in parallel.\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @returns {Promise<string>} - A Promise that resolves with the Newick string of the best rooted tree.\n */\nexport async function globalRootParallel(nwk: string, dates: number[], tipData: any) {\n\n  var t0 = new Date().getTime();\n\n  const tree = new phylotree(nwk);\n\n  var nodes = tree.nodes.descendants();\n  var nodeNums = nodes.map((e: any, i: number) => i).slice(1);\n  //var nodeNums = nodes.map((e: any, i: number) => i).slice(1).map((e: number) => 36)\n\n  var nodeNumsChunked = \n  nodeNums.length > window.navigator.hardwareConcurrency\n  ?\n    spliceIntoChunks(\n      nodeNums,\n      (nodeNums.length - 1) / window.navigator.hardwareConcurrency\n    )\n  :\n    [nodeNums];\n\n  var promises = nodeNumsChunked.map((e: number[]) =>\n    createWorker(nwk, dates, e, tipData)\n  );\n\n  var prime = (await Promise.all(promises));\n\n  prime.unshift({\n    ...localRoot(tree, tipData),\n    nodeIndx: 0,\n  });\n\n  var r2 = prime.map((e: any) => e.r2);\n\n  var bestR2 = Math.max(...r2);\n\n  var bestIndx = r2.indexOf(bestR2);\n  var best: any = prime[bestIndx];\n\n  let bestTree = new phylotree(nwk);\n\n  rerootAndScale(bestTree, best);\n\n  var t1 = new Date().getTime()\n\n  console.log(\"Time Taken for BFR \" + Math.abs(t1-t0) / 1000 + \"s\")\n\n  return bestTree.getNewick();\n}\n\n/**\n * Reroots at best node and rescales basal branch lengths.\n * \n * @param {any} bestTree - The best rooted phylotree instance.\n * @param {any} best - The best local optima information.\n */\nexport function rerootAndScale(bestTree: any, best: any) {\n\n  let l1 = getLength(bestTree)\n\n  if (best.nodeIndx !== 0) {\n    bestTree.reroot(bestTree.nodes.descendants()[best.nodeIndx]);\n  } else if (best.nodeIndx === 0) {\n    bestTree.nodes.each((n: any) => {\n      n.data.__mapped_bl = bestTree.branch_length_accessor(n);\n    });\n  }\n    \n    let bl = [\n      bestTree.branch_length_accessor(bestTree.nodes.children[0]),\n      bestTree.branch_length_accessor(bestTree.nodes.children[1]) \n    ].map (\n      e => parseFloat(e)\n    )\n    let len = bl.reduce((a,b) => a+b, 0)\n\n    bestTree.nodes.children[0].data.__mapped_bl = (best.alpha * len);\n    bestTree.nodes.children[1].data.__mapped_bl = ((1 - best.alpha) * len);\n\n    let l2 = getLength(bestTree)\n\n    if (l1 !== l2) {\n      console.log(`Mismatch Node`)\n      console.log(best.nodeIndx)\n      console.log(`${len} vs ${l1-l2}`)\n      console.log(bl)\n    }\n\n}\n\n\n/**\n * Finds the best local root for a given phylogenetic tree.\n *\n * @param {any} tree - A phylotree instance representing the phylogenetic tree.\n * @param {number[]} dates - An array of dates associated with each tip of the tree.\n * @returns {object} - An object containing the best alpha value and the corresponding R2 value.\n */\nexport function localRoot(tree: any, tipData: any) {\n  var tipNames: string[] = getTipNames(tree);\n  var tipHeights: number[] = getTipHeights(tree); \n\n  var oldHeightSum = tipHeights.reduce((a,b) => a+b);\n  let nLeft: number;\n  if(tree.nodes.children[0]) {\n    nLeft = tree.nodes.children[0].leaves().length;\n  } else {\n    nLeft = 1;\n  }\n  let nRight = tree.getTips().length - nLeft;\n\n  var dates = tipNames.map(e => tipData[e].date)\n\n  var desc0: string[] = tree.nodes.children[0].leaves().map(\n    (e: any) => e.data.name\n  );\n\n  var indicator: boolean[] = [];\n  for (let i = 0; i < tipNames.length; i++) {\n    desc0.includes(tipNames[i]) ? indicator.push(true) : indicator.push(false);\n  }\n\n  let bl = [\n    tree.branch_length_accessor(tree.nodes.children[0]),\n    tree.branch_length_accessor(tree.nodes.children[1])\n  ].map(e => parseFloat(e))\n\n  let length = bl.reduce((a, b) => a+b, 0)\n\n  // Skipping opimisation for effectively 0-length branches\n  if (length < Number.EPSILON) {\n    console.log('Skipping node!');\n    return { \n      alpha: 0.5, \n      r2: linearRegression({ x: dates, y: tipHeights, tip: tipNames, name: 'NA' }).r2\n    }\n  }\n\n  function univariateFunction(x: number) {\n\n    let tipHeightsNew = tipNames.map((e, i) => { // UPTO: Issue must be in bl, length, or heights\n      if (indicator[i]) {\n        return tipHeights[i] - bl[0] + (x*length);\n      } else {\n        return tipHeights[i] - bl[1] + (1-x)*length;\n      }\n    });\n\n    return -1 * linearRegression({ x: dates, y: tipHeightsNew, tip: tipNames, name: 'NA' }).r2;\n  };\n\n  let alpha = minimize(univariateFunction, { lowerBound: 0, upperBound: 1, tolerance: Number.EPSILON, maxIterations: 1000});\n  \n  return { alpha: alpha, r2: -1 * univariateFunction(alpha) };\n}\n\ninterface TipIndices {\n  [key: string]: number;\n}\n\n/**\n * Reorders an array of data based on the correspondence between the current and target tip names.\n *\n * @param {number[]} arr - The array of data to be reordered.\n * @param {string[]} currentTip - An array of the current tip names.\n * @param {string[]} targetTip - An array of the target tip names.\n * @returns {number[]} - The reordered array of data.\n */\nexport function reorderData(arr: number[], currentTip: string[], targetTip: string[]) {\n  const targetTipIndices: TipIndices = {};\n  for (let i = 0; i < targetTip.length; i++) {\n    targetTipIndices[targetTip[i]] = i;\n  }\n\n  const arrOrdered = currentTip.map((tip) => {\n    const index = targetTipIndices[tip];\n    return arr[index];\n  });\n\n  return arrOrdered;\n}\n\n/**\n * Splits an array into chunks of the specified size.\n *\n * @param {number[]} arr - The array to be split into chunks.\n * @param {number} chunkSize - The size of each chunk.\n * @returns {number[][]} - An array of chunks.\n */\nfunction spliceIntoChunks(arr: number[], chunkSize: number) {\n  const res = [];\n  while (arr.length > 0) {\n    const chunk = arr.splice(0, chunkSize);\n    res.push(chunk);\n  }\n  return res;\n}","import { phylotree } from \"phylotree\";\nimport { localRoot, localOptima, reorderData } from \"./bestFittingRoot\";\nimport { getTipNames } from \"./utils\";\n\n\n\n// this runs on the webworker, created with webpack 5 syntax new\n// Worker('./worker.ts'). in jest tests, this module is not used, instead the\n// workerMessageHandler is directly addressed\nself.onmessage = ({ data: { nwk, dates, nodeNums, tipData } }) => { /* eslint-disable-line no-restricted-globals */\n  var tree = new phylotree(nwk)\n  var treePrime: any = {}\n  var datesPrime: number[] = []\n  var localOptimum: localOptima\n  var best: localOptima\n\n  // first node case\n  treePrime = new phylotree(nwk);\n  treePrime.reroot(treePrime.nodes.descendants()[nodeNums[0]]);\n\n  datesPrime = getTipNames(treePrime).map(\n    e => tipData[e].date\n  )\n  var grpPrime = getTipNames(treePrime).map(\n    e => tipData[e].group\n  )\n\n  best = {\n    ...localRoot(\n      treePrime,\n      tipData\n    ),\n    nodeIndx: nodeNums[0]\n    }\n\n  // compare to rest of nodes\n  for (let i=1; i<nodeNums.length; i++) {\n    treePrime = new phylotree(nwk);\n\n    treePrime.reroot(treePrime.nodes.descendants()[nodeNums[i]]);\n    // treePrime.setBranchLength(\n    //   (n: any) => n.data.__mapped_bl\n    // ) // not sure this is needed anymore\n\n    localOptimum = {\n      ...localRoot(\n        treePrime,\n        tipData\n      ),\n      nodeIndx: nodeNums[i]\n    }\n    \n    if (localOptimum.r2 - best.r2 > Number.EPSILON) {\n      best = localOptimum;\n    }\n  }\n\n  self.postMessage(best); /* eslint-disable-line no-restricted-globals */\n}; ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [805,492], function() { return __webpack_require__(74245); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"245\":\"ecdaea78\",\"492\":\"c5f12f55\",\"805\":\"d86e3fb0\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t245: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkclockor2\"] = self[\"webpackChunkclockor2\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([\n\t\t__webpack_require__.e(805),\n\t\t__webpack_require__.e(492)\n\t]).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["require","linearRegression","points","reg","tip","x","y","sum_x","n","length","sum_y","sum_xy","sum_xx","sum_yy","j","slope","intercept","fitY","map","e","r2","Math","pow","sqrt","sigSq","i","a","reduce","b","logLik","log","mu","exp","PI","E","normalDensity","dfs","tree","node","distanceFromRoot","leafDistances","children","forEach","child","distance","Number","branch_length_accessor","set","data","name","computeDistances","Map","nodes","getTipNames","getTips","minimize","localRoot","tipData","nLeft","tipNames","tipHeights","distances","get","getTipHeights","leaves","dates","date","desc0","indicator","includes","push","bl","parseFloat","EPSILON","console","alpha","univariateFunction","tipHeightsNew","lowerBound","upperBound","tolerance","maxIterations","self","onmessage","localOptimum","best","nwk","nodeNums","treePrime","phylotree","reroot","descendants","group","nodeIndx","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","every","key","splice","r","d","definition","o","defineProperty","enumerable","f","chunkId","Promise","all","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","value","nmd","paths","p","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}