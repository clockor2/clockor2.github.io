{"version":3,"file":"static/js/907.7e480183.chunk.js","mappings":"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","sources":["features/engine/core.ts","features/engine/utils.ts","features/engine/clockSearch.ts","features/engine/clockSearchWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/node module decorator","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import { date_decimal } from \"./utils\";\nconst chroma = require(\"chroma-js\") // TODO: Learn about why this works instead of import\n\n// class to contain local clock model, incl. data points and information criteria\nexport interface LocalClockModel {\n  baseClock: Regression;\n  localClock: Regression[];\n  baseIC: InfoMetric;\n  localIC: InfoMetric;\n  groupNames: string[];\n}\n// interface for info metric data\ninterface InfoMetric {\n  aic: number;\n  aicc: number;\n  bic: number;\n}\n\n// function to make plottable points\n// method for plotly plotting\nexport function plotify(lcm: LocalClockModel | null): Plotly.Data[] | null {\n  const plot = [] as Plotly.Data[];\n  if (lcm != null) {\n    // generate colour scale. Use viridis-ish default\n    const cols = lcm.localClock\n      ?\n      chroma.scale(['#fafa6e', '#2A4858']).mode('lch').colors(lcm.localClock.length)\n      :\n      \"DarkSlateGrey\";\n\n    // Pushing plotly object for base lock\n    var point = {\n      x: lcm.baseClock.x.map(e => date_decimal(e)),\n      y: lcm.baseClock.y,\n      text: lcm.baseClock.tip,\n      marker: {color: '#000000', size: 5},\n      mode: \"markers\",\n      name: \"Global\",\n      legendgroup: \"Global\",\n      showlegend: false\n    }\n    plot.push(point);\n\n    var line = {\n      x: lcm.baseClock.x.map(e => date_decimal(e)),\n      y: lcm.baseClock.fitY,\n      name: \"Global\",\n      marker : {color: '#000000'},\n      mode: \"lines\",\n      text: lcm.localClock\n      ? \n        `Global<br>R2: ${lcm.baseClock.r2.toFixed(2)}` \n      : \n        `R2: ${lcm.baseClock.r2.toFixed(2)}`,\n\n      legendgroup: \"Global\"\n    }\n    plot.push(line);\n\n    // pushing plotly object for each local clock\n    if (lcm.localClock){\n      for (let i = 0; i < lcm.localClock.length; i++) {\n        var point1 = {\n          x: lcm.localClock[i].x.map(e => date_decimal(e)),\n          y: lcm.localClock[i].y,\n          text: lcm.localClock[i].tip,\n          marker: {color: cols[i], line: {width: 1, color: 'DarkSlateGrey'}},\n          mode: \"markers\",\n          legendgroup: lcm.groupNames[i+1].length > 1 ? lcm.groupNames[i+1] : `Local Clock ${i+1}`,\n          name: lcm.groupNames[i+1],\n          showlegend: false\n        }\n        plot.push(point1);\n\n        var line1 = {\n          x: lcm.localClock[i].x.map(e => date_decimal(e)),\n          y: lcm.localClock[i].fitY,\n          text: `${lcm.groupNames[i+1] ?? `Local Clock ${i+1}`}<br>R2: ${lcm.localClock[i].r2.toFixed(2)}`,\n          marker : {color: cols[i], line: {width: 1, color: 'DarkSlateGrey'}},\n          mode: \"lines\",\n          legendgroup: lcm.groupNames[i+1].length > 1 ? lcm.groupNames[i+1] : `Local Clock ${i+1}`,\n          name: lcm.groupNames[i+1]\n        }\n        plot.push(line1);\n      }\n    }\n      return plot;\n  } else {\n    return null;\n  }\n  }\n\n\n\ninterface Style {\n  color: string;\n}\n\nexport interface Regression {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  fitY: Array<number>;\n  slope: number;\n  intercept: number;\n  sigSq: number;\n  r2: number;\n  logLik: number;\n}\n\n// Groups of points pertaining to one local clock\n// To be apended in array for linearRegression()\ninterface DataGroup {\n  x: Array<number>;\n  y: Array<number>;\n  tip: Array<string>;\n  name: string;\n}\n\n//////////////////////////////////////////////////////\n// BELOW: CORE ENGINE FUNCTIONS SUCH AS SOMETHING() //\n// INCORPORATE FUNCTIONS DEFINED BELOW              //\n//////////////////////////////////////////////////////\n\n// Core function. Functionality for groups to be added\nexport const regression = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings: Array<string>,\n  tipNames: Array<string>) => {\n\n  var dataPoints = groupData(tipHeights, dates, groupings, tipNames);\n\n  var lcm = {} as LocalClockModel;\n  \n  lcm.baseClock = linearRegression(dataPoints[0]);\n  lcm.baseIC = {} as InfoMetric;\n  lcm.baseIC.aic = AIC([lcm.baseClock]);\n  lcm.baseIC.aicc = AICc([lcm.baseClock]);\n  lcm.baseIC.bic = BIC([lcm.baseClock]);\n\n  if (dataPoints.length > 1) {\n    lcm.localClock = dataPoints.slice(1).map(e => linearRegression(e));\n    lcm.localIC = {} as InfoMetric;\n    lcm.localIC.aic = AIC(lcm.localClock);\n    lcm.localIC.aicc = AICc(lcm.localClock);\n    lcm.localIC.bic = BIC(lcm.localClock);\n  }\n\n  lcm.groupNames = dataPoints.map(e => e.name)\n  \n  return lcm;\n}\n\n// Clock search function. Conver to a generator later\n// icMetric is the information criterion used to find 'best' state. TODO: Need to read these as part of input: aic | aicc | bic\n// export const clockSearch = (tree: any,\n//   minCladeSize: number,\n//   numClocks: number,\n//   tipHeights: Array<number>,\n//   dates: Array<number>,\n//   tipNames: Array<string>,\n//   icMetric: string) => {\n\n//   // generate all possibilities for groupings\n//   let allGroups = getGroups(tree, minCladeSize, numClocks);\n//   let allGroupsNumber = allGroups.map((e: string[][]) => groupToNum(e, tips));\n\n//   // Loop through group possibilities and append to fits\n//   let fits: LocalClockModel[] = [];\n//   for (let i = 0; i < allGroups.length; i++){\n//       fits.push(regression(tipHeights, dates, allGroups[i], tipNames)); \n//   }\n\n//   // Now find the most supported configuration\n//   // Getting array of IC values based on selected IC TODO: Add capability for multiple ICs\n//   const ic = fits.map(e => e[icMetric as keyof LocalClockModel]) // TODO: Test here!\n\n//   var icMaxStep = ic.indexOf(Math.max(...(ic as number[]))); // TODO: This might throw an error if we never see output\n\n//   return fits[icMaxStep];\n// }\n\n////////////////////////////////////////////////////////\n// BELOW: FUNCTIONS USED INSIDE CORE ENGINE FUNCTIONS //\n////////////////////////////////////////////////////////\n\n// function groups points for local clock regresion\n// 0th element of array is always points for single clock\nconst groupData = (\n  tipHeights: Array<number>,\n  dates: Array<number>,\n  groupings:  Array<string>,\n  tipNames: Array<string>\n  ): DataGroup[] => { \n\n  const points: DataGroup[] = [];\n\n  let unique = groupings.filter((v, i, a) => a.indexOf(v) === i).sort();\n  let numericGroupings =  groupings.map(group => unique.indexOf(group))\n\n  for (let i = 0; i < unique.length; i++) {\n    var tmp: DataGroup = {x: [], y: [], tip: [], name: unique[i]};\n    points.push(tmp);\n  }\n\n  for (let i = 0; i < groupings.length; i++) {\n    points[numericGroupings[i]].x.push(\n      dates[i]\n    )\n    points[numericGroupings[i]].y.push(\n      tipHeights[i]\n    )\n    points[numericGroupings[i]].tip.push(\n      tipNames[i]\n    )\n  }\n  // if  num groups > 1, append the baseline fit (all points in one group)\n  // In the case num groups = 1, this is automatically appended\n  if (unique.length > 1) {\n    points.unshift({\n      x: dates,\n      y: tipHeights,\n      tip: tipNames,\n      name: \"Global\"\n    })}\n\n  return points;\n}\n\n// regression function \nexport function linearRegression(points: DataGroup) {\n  let reg = {} as Regression;\n\n  // carrying tips over first\n  reg.tip = points.tip;\n\n  let x = points.x;\n  let y = points.y;\n\n  let sum_x = 0;\n  let n = y.length;\n  let sum_y = 0;\n  let sum_xy = 0;\n  let sum_xx = 0;\n  let sum_yy = 0;\n\n  for (let j = 0; j < y.length; j++) {\n      sum_x += x[j];\n      sum_y += y[j];\n      sum_xy += (x[j]*y[j]);\n      sum_xx += (x[j]*x[j]);\n      sum_yy += (y[j]*y[j]);\n  } \n\n  // Include these later after agreeing on how to pass to front end\n  reg.x = x;\n  reg.y = y;\n  reg.slope = (n * sum_xy - sum_x * sum_y) / (n*sum_xx - sum_x * sum_x);\n  reg.intercept = (sum_y - reg.slope * sum_x)/n;\n  reg.fitY = x.map(e => (reg.slope * e + reg.intercept));\n  reg.r2 = Math.pow((n*sum_xy - sum_x*sum_y)/Math.sqrt((n*sum_xx-sum_x*sum_x)*(n*sum_yy-sum_y*sum_y)),2);\n  //calculate log likelihood\n  \n  let error = y.map((n, i, a) => y[i] - reg.fitY[i]); \n  // estiamted variance of error\n  let sigSq = error.map(n => Math.pow(n, 2)).reduce(\n    (a, b) => a + b, 0) * (1 / reg.fitY.length);\n  //reg.logLik = y.map((e, i) => Math.log(normalDensity(e, reg.fitY[i], sigSq))).reduce((a, b) => a + b); \n  reg.logLik = y.map((e, i) => Math.log(\n    normalDensity(e, reg.fitY[i], sigSq)\n    )\n    ).reduce(\n      (a, b) => a + b\n      ); \n\n  return reg;\n}\n\n// Function for likelihood in linearRegression() function\n export function normalDensity(y: number, mu: number, sigSq: number) {\n  let exp = -0.5 * ((y - mu) ** 2) / sigSq; // exponent\n  let norm = 1 / (Math.sqrt(2 * Math.PI * sigSq)); // normalising factor\n  return norm * (Math.E ** exp);\n}\n\n// Information criteria functions below \nexport function AICc(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + ((6 * f * n) / (n - (3 * f) - 1))); \n}\n\nexport function AIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (-2 * totLogLik + (6 * f)); \n}\n\nexport function BIC(regs: Regression[]): number {\n  var f = regs.length;\n  var n = regs.map((n, i, a) => regs[i].y.length).reduce(\n    (a, b) => a + b, 0)\n  var totLogLik = 0;\n\n  for (let i = 0; i < regs.length; i++) {\n    if (regs[i].logLik) {\n      totLogLik += regs[i].logLik;\n    }\n  }\n    return (3 * f * Math.log(n) - (2 * totLogLik)); \n}\n\nexport function getGroups (tree: any, minCladeSize: number, numClocks: number): string[][][] {\n  // Sets of tips descending from each node\n  var tips: any = [];\n  // list tips descending from each node\n  tree.nodes.each((node: any) => tips.push(node.leaves())); \n  // map to just tip names\n  var tips = tips.map((e0: any) => e0.map((e1: any) => e1.data.name));\n  // De-duplicate tips (artefact from d3 hierarchy)\n  var uniqueTips = tips.map(\n    (e: string[]) => JSON.stringify(e)\n    ).filter(\n      (e: string[], i: number, a: string[][]) => {return a.indexOf(e) === i}\n      ).map(\n       (e: string) => JSON.parse(e)\n        )\n  // Sort clades based on size. Largest (all tips) goes first\n  var sortedUniqueTips = uniqueTips.sort((a: string[], b: string[]) => {return b.length - a.length});\n\n  // Filter out all clades with fewer than ${minCladeSize} tips\n  var finalClades = sortedUniqueTips.filter((e: string[]) => e.length >= minCladeSize);\n\n  // array from 1:(finalClades.length) possible clades to draw combinations\n  var grpNums = Array.from(Array(finalClades.length).keys());\n  // +1 to account for 0th base clock\n  //var grpNums = grpNums.map((e: number, i: number ) => i+1); \n  \n  // remove 0th group - that being all tips. Add back in later\n  grpNums.shift()\n  // get all combinations of groups to make up ${numClocks} local clocks\n  let comb = combn(grpNums, (numClocks - 1))\n  // add 0th clade for background rate\n  comb.map((e: number[]) => e.unshift(0)); \n\n  // Convert number combinations to corresponding groups of tips\n  let allGroups: string[][][] = [];\n  for (let i = 0; i < comb.length; i++){\n    allGroups.push(\n      comb[i].map(\n        (e: number) => finalClades[e]\n      )\n    );\n  }\n\n  //return groups after converting to non-intersecting groups;\n  return allGroups.map(e => getUnique(e));\n\n  // TODO: Size-filtering and defend against requesting too many clocks\n}\n\n// function takes string[][] and maps each to unique values assuming each string[] is nested as for allGroups\nexport function getUnique(x: string[][]): string[][] {\n  return x.map((e0: string[], i) => e0.filter(\n      (e1: string) => {\n        if(i+1 < x.length) { \n          return !x[i+1].includes(e1); \n        } else {\n          return true;\n        }\n      })\n  );\n}\n\n// A function that takes a list of tips and returns group number based on an element of allGroups\nfunction groupToNum(arr: string[][], tips: string[]): number[] {\n    let groupings: number[] = []; \n\n    for (let i = 0; i < tips.length; i++){\n      var tmp = [];\n      \n      for (let j = 0; j < arr.length; j++) {\n        if (arr[j].indexOf(tips[i]) > -1) {\n          groupings[i] = j;\n        } \n      }\n    }\n  return groupings;\n} // TODO: Include a test here to check that output is all integers and that ordering of tips matches input\n\n\n// generating combinations of groups\n export function combn(arr: any[], k: number): number[][] {\n  // Store all possible combinations in a result array\n  const result: number[][] = [];\n\n  // Generate all combinations using a recursive helper function\n  function generateCombinations(currentIndex: number, currentCombination: any[]): void {\n    // If the current combination has the desired length, add it to the result array\n    if (currentCombination.length === k) {\n      result.push(currentCombination);\n      return;\n    }\n\n    // Generate all possible combinations starting from the next element in the array\n    for (let i = currentIndex; i < arr.length; i++) {\n      generateCombinations(i + 1, currentCombination.concat(arr[i]));\n    }\n  }\n\n  // Start the recursive process with the first element in the array\n  generateCombinations(0, []);\n\n  // Return the result array\n  return result;\n}\n","\nexport const decimal_date = (sampDate: string, format: \"yyyy-mm-dd\" | \"decimal\") => {\n  if (format === \"yyyy-mm-dd\"){\n      let date = new Date(sampDate)\n      let yr = date.getFullYear();\n      let m = date.getMonth() ?? 0;\n      let d = date.getDate() ?? 0;\n\n      let decimal_date_value = (\n        yr +\n        m / 12 +\n        d / 365.25\n      )\n\n      return decimal_date_value;\n  } else  {\n    let decimal_date = parseFloat(sampDate) \n    return decimal_date\n  }\n  };\n\nexport const date_decimal = (sampDate: number): Date => {\n    var year = parseInt(sampDate.toString());\n    var reminder = sampDate - year;\n    var daysPerYear = 365.25\n    var miliseconds = reminder * daysPerYear * 24 * 60 * 60 * 1000;\n    var yearDate = new Date(year, 0, 1);\n    return new Date(yearDate.getTime() + miliseconds);\n};\n\nexport const createGroups = (decimal_dates:number[], tipHeights: number[], tipNames: number[], groupings:number[]) => {\n    /**\n     * Splits arrays into groups \n     * This method returns a array of group objects\n     */\n    let unique = groupings.filter((v, i, a) => a.indexOf(v) === i);\n    let groups = unique.map(() => {return {tipHeights:[] as number[], decimal_dates:[] as number[], tipNames: [] as number[]}})\n\n    for (let index = 0; index < groupings.length; index++) {\n      groups[groupings[index]].decimal_dates.push(\n        decimal_dates[index]\n      )\n      groups[groupings[index]].tipHeights.push(\n        tipHeights[index]\n      )\n      groups[groupings[index]].tipNames.push(\n        tipNames[index]\n      )\n    }\n    return groups\n  }\n\n  interface TreeNode {\n    data: {\n      name: string;\n      attribute?: number;\n    };\n    children?: TreeNode[];\n\n  }\n  function dfs(tree: any, node: TreeNode, distanceFromRoot: number, leafDistances: Map<string, number>): Map<string, number> {\n    if (!node.children || node.children.length === 0) {\n      leafDistances.set(node.data.name, distanceFromRoot);\n    } else {\n      node.children.forEach((child) => {\n        const distance = Number(tree.branch_length_accessor(child)) || 0;\n        dfs(tree, child, distanceFromRoot + distance, leafDistances);\n      });\n    }\n    return leafDistances;\n  }\n  \n  export function computeDistances(tree: any): Map<string, number> {\n    const leafDistances = new Map<string, number>();\n    return dfs(tree, tree.nodes, 0, leafDistances);\n  }\n\n  export const getTipHeights = (tree: any): number[] => {\n    let distances = computeDistances(tree)\n    return tree.getTips().map((tip: any) => distances.get(tip.data.name)) // reorder the nodes \n  }\n\n  export const getTipNames = (tree: any): string[] => {\n    return tree.getTips().map((tip: any) => tip.data.name);\n  }\n\n  export function rootToNodeDistance(tree: any, nodeNum: number) {\n    let node = tree.nodes.descendants()[nodeNum];\n    let dist = 0;\n    while(node) {\n      if (tree.branch_length_accessor(node)) {\n        dist += tree.branch_length_accessor(node)\n      } else {\n        dist += 0\n      }\n\n      node = node.parent;\n    }\n\n    return dist;\n  }\n\n  export function rootTipDistances(tree: any) {\n\n    tree.nodes.each((n: any) => {\n      if (n.parent) {\n        n.data.rootDist = Number(tree.branch_length_accessor(n)) + n.parent.data.rootDist;\n      } else {\n        n.data.rootDist = 0\n      }\n    })\n\n    let rootDists = tree.getTips().map((e: any) => e.data.rootDist)\n    return rootDists;\n\n  }\n\n  export function getLength(tree: any) {\n\n    return tree.nodes.descendants().slice(1).map(\n      (n: any) => tree.branch_length_accessor(n)\n    ).reduce(\n      (a: number, b: number) => a+b\n    )\n\n  }","import { phylotree } from \"phylotree\" \nimport { regression, LocalClockModel } from \"./core\"\nimport { getTipHeights, getTipNames } from \"./utils\"\n\n/**\n * Creates a web worker for clock search in background thread\n *\n * @param {string} nwk - The Newick string representing the phylogenetic tree.\n * @param {number} minCladeSize - Minimum group size for search\n * @param {number} maxClocks - Max clocks to search for. Searches for 1..maxClocks\n * @param {number[]} dates - Tip dates\n * @param {\"aic\" | \"aicc\" | \"bic\"} icMetric - Information criterion used to determine best config. BIC reccommened.\n * @returns {Promise} - A Promise that resolves with the worker's response data.\n */\nexport function createClockSearchWorker(\n  nwk: string, \n  minCladeSize: number,\n  maxClocks: number,\n  dates: number[], \n  icMetric: \"aic\" | \"aicc\" | \"bic\"\n  ): Promise<LocalClockModel> {\n  return new Promise(function (resolve, reject) {\n    const worker = new Worker(new URL(\"./clockSearchWorker.ts\", import.meta.url));\n    worker.postMessage({\n      nwk: nwk, \n      minCladeSize: minCladeSize,\n      maxClocks: maxClocks,\n      dates: dates, \n      icMetric: icMetric\n    });\n    worker.onmessage = (e) => {\n      resolve(e.data);\n    };\n    worker.onerror = reject;\n  });\n}\n\n// Clock search function. Conver to a generator later\n// icMetric is the information criterion used to find 'best' state. TODO: Need to read these as part of input: aic | aicc | bic\nexport const clockSearch = (\n    nwk: string,\n    minCladeSize: number,\n    maxClocks: number,\n    dates: Array<number>,\n    icMetric: \"aic\" | \"aicc\" | \"bic\"\n    ) => {\n  \n    var tree = new phylotree(nwk)\n    \n    var allGroups: string[][][] = [];\n    for (let i = 1; i <= maxClocks; i++) {\n        allGroups = allGroups.concat(\n            getGroups(\n                tree,\n                minCladeSize,\n                i\n            ))\n    }\n    // converting to group string\n    var allTips = tree.getTips().map((e: any) => e.data.name)\n\n    // error for too many clocks\n    const error = Error(`Too may clocks for minimum clade size. Spurious results await`)\n    if (maxClocks > Math.floor(allTips.length / minCladeSize) ){\n      console.error(error.message)\n    } \n\n\n    var groupsNumbered = allGroups.map(\n      (e:string[][]) => makeGroups(\n        allTips, \n        e)\n    )\n\n    var tipNames = getTipNames(tree);\n    var tipHeights = getTipHeights(tree);\n    \n    var fits: LocalClockModel[] = [];\n    for (let i = 0; i < allGroups.length; i++){\n        fits.push(\n            regression(\n                tipHeights,\n                dates,//TODO: is dates in the right order? - keep in state?\n                groupsNumbered[i],\n                tipNames\n                )\n            );     \n    }\n\n    // Now find the most supported configuration. Want baseIC iff only one group\n    var ic: number[] = fits.map(\n        e => e.localClock ? e.localIC[icMetric] : e.baseIC[icMetric]\n        );\n\n    var minIC = Math.min(...ic); \n\n    var indexBest = ic.indexOf(minIC);\n    return fits[indexBest];\n  }\n  \n  export function getGroups (tree: any, minGroupSize: number, numClocks: number): string[][][] {\n    var tipNodes = tree.getInternals().map((e: any) => e.leaves())\n\n    // TODO: Throw error if numClocks > nTips / minGroupSize. Needs Parse Int\n\n    var tips = tipNodes.map(\n      (e: any) => e.map((e1: any) => e1.data.name)\n      ).sort(\n        (a: string[], b: string[]) => {return b.length - a.length}\n      ).filter(\n        (e: string[]) => e.length >= minGroupSize\n      );\n  \n    // [1,...,tips.length] as array for combn()\n    let nums = [...Array(tips.length)].map((e, i) => i).slice(1);\n\n    var combinations: number[][] = combn(nums, (numClocks - 1));\n    \n    // return 0th clade for background rate, sort, and find unique\n    combinations.map(\n        (e: number[]) => e.unshift(0)\n        )\n\n    // Convert number combinations to corresponding groups of tips\n    var allGroups: string[][][] = [];\n    var tmp: string[][] = []\n    for (let i = 0; i < combinations.length; i++){\n      tmp = combinations[i].map(\n        (e: number) => tips[e]\n      )\n      allGroups.push(tmp);\n    }\n\n    allGroups = allGroups.map(e => unNest(e))\n    // allGroups = allGroups.map(e => e.sort()) // sorting for testing\n    \n    // Filter out all groups with fewer than ${minCladeSize} tips\n    var finalGroups = allGroups.filter(\n      (e0: string[][]) => !(\n        e0.some(\n          (e1: string[]) => e1.length < minGroupSize\n        )\n      ) \n    );\n\n    // de-duplicating\n    finalGroups = finalGroups.map(\n      e => JSON.stringify(e)\n    ).filter(\n      (v,i,a)=>a.indexOf(v)===i\n    ).map(\n      e => JSON.parse(e)\n    )\n\n    return finalGroups;\n\n  }\n\n// Make groups into a 1D array of numbers coresponding to tips. TODO: test\nexport function makeGroups(tips: string[], nestedGrp: string[][]): string[] {\n let grp: string[] = []\n\n for (let i=0; i<tips.length; i++){\n  for (let j=nestedGrp.length-1; j>=0; j--){\n\n    if (nestedGrp[j].includes(tips[i])){\n      grp.push(j.toString())\n      break\n    } \n  \n  }\n }\n\n return grp;\n}\n\n  \n  // Un-nests group membership\n  export function unNest(arr: string[][]): string[][] {\n    var unNested: string[][] = [];\n\n    unNested[arr.length-1] = arr[arr.length-1];\n    for (let i = arr.length-2; i>=0; i--){\n      unNested[i] = arr[i].filter(\n        (e: string) => !arr.slice(i+1).flat().includes(e)\n      )\n    }\n    return unNested.sort();\n  }\n  \n  // generating combinations of groups\n   export function combn(arr: any[], k: number): number[][] {\n    // Store all possible combinations in a result array\n    const result: number[][] = [];\n  \n    // Generate all combinations using a recursive helper function\n    function generateCombinations(currentIndex: number, currentCombination: any[]): void {\n      // If the current combination has the desired length, add it to the result array\n      if (currentCombination.length === k) {\n        result.push(currentCombination);\n        return;\n      }\n  \n      // Generate all possible combinations starting from the next element in the array\n      for (let i = currentIndex; i < arr.length; i++) {\n        generateCombinations(i + 1, currentCombination.concat(arr[i]));\n      }\n    }\n  \n    // Start the recursive process with the first element in the array\n    generateCombinations(0, []);\n  \n    // Return the result array\n    return result;\n  }\n  ","import { clockSearch } from \"./clockSearch\";\n\n// this runs on the webworker, created with webpack 5 syntax new\n// Worker('./worker.ts'). in jest tests, this module is not used, instead the\n// workerMessageHandler is directly addressed\nself.onmessage = ( /* eslint-disable-line no-restricted-globals */\n  { \n    data: { \n      nwk,\n      minCladeSize,\n      maxClocks,\n      dates,\n      icMetric  \n    } \n  }\n) => { /* eslint-disable-line no-restricted-globals */\n \n  let bestGrpConfig = clockSearch(\n      nwk,\n      minCladeSize,\n      maxClocks,\n      dates,\n      icMetric\n    )\n  \n  self.postMessage(bestGrpConfig); /* eslint-disable-line no-restricted-globals */\n}; ","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [805,928], function() { return __webpack_require__(51907); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"805\":\"d86e3fb0\",\"907\":\"7e480183\",\"928\":\"148ac088\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = function(module) {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.p = \"/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t907: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkclockor2\"] = self[\"webpackChunkclockor2\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([\n\t\t__webpack_require__.e(805),\n\t\t__webpack_require__.e(928)\n\t]).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["require","regression","tipHeights","dates","groupings","tipNames","dataPoints","groupData","lcm","baseClock","linearRegression","baseIC","aic","AIC","aicc","AICc","bic","BIC","length","localClock","slice","map","e","localIC","groupNames","name","points","unique","filter","v","i","a","indexOf","sort","numericGroupings","group","tmp","x","y","tip","push","unshift","reg","sum_x","n","sum_y","sum_xy","sum_xx","sum_yy","j","slope","intercept","fitY","r2","Math","pow","sqrt","sigSq","reduce","b","logLik","log","mu","exp","PI","E","normalDensity","regs","f","totLogLik","dfs","tree","node","distanceFromRoot","leafDistances","children","forEach","child","distance","Number","branch_length_accessor","set","data","computeDistances","Map","nodes","clockSearch","nwk","minCladeSize","maxClocks","icMetric","phylotree","allGroups","concat","getGroups","allTips","getTips","error","Error","floor","console","message","groupsNumbered","tips","nestedGrp","grp","includes","toString","makeGroups","getTipNames","distances","get","getTipHeights","fits","ic","minIC","min","minGroupSize","numClocks","getInternals","leaves","e1","nums","Array","combinations","arr","k","result","generateCombinations","currentIndex","currentCombination","combn","unNested","flat","unNest","finalGroups","e0","some","JSON","stringify","parse","self","onmessage","bestGrpConfig","postMessage","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","id","loaded","__webpack_modules__","call","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","every","key","splice","r","d","definition","o","defineProperty","enumerable","chunkId","Promise","all","promises","u","miniCssF","g","globalThis","this","Function","window","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","value","nmd","paths","p","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next","then"],"sourceRoot":""}